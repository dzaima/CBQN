t0g â† â€¢MonoTime@
#!build/obj2/for_build
# to emulate on makefile transition: NO_LDL â†’ rm_lf=-ldl; no_fPIC â†’ rm_f=-fPIC; something something PIE

âŸ¨Spawn, WaitForOneâŸ© â† âŸ¨âŸ© â€¢Import "fork.bqn"
âŸ¨Serialize, DeserializeâŸ© â† â€¢Import "serialize.bqn"

# modes:
#  0: single string option
#  1: toggle
#  2: flag list
opts â† âŸ¨
  âŸ¨0, "j", "4"âŸ©       # number of parallel jobs
  âŸ¨1, "verbose", 0âŸ©   # log more things
  âŸ¨1, "rebuild", 0âŸ©   # forcibly rebuild everything
  # TODO clean
  
  âŸ¨0, "CC", @âŸ© # the C compiler
  âŸ¨0, "LD", @âŸ©       # linker of the final binary; default CC, or CXX if REPLXX=1
  âŸ¨1, "color", 1âŸ©    # whether to enable colored diagnostics
  âŸ¨0, "os", @âŸ©       # target OS (linux, bsd, macos); used for .so vs .dylib, and changing linker flags for bsd
  âŸ¨0, "arch", @âŸ©     # target architecture (x86-64, aarch64, generic); used for Singeli target deciding
  
  âŸ¨0, "OUTPUT", ""âŸ©  # output location; default depends
  âŸ¨2, "f", âŸ¨âŸ©âŸ©       # C flags for CBQN files
  âŸ¨2, "CCFLAGS", âŸ¨âŸ©âŸ© # flags for all C compiler & linker invocations
  âŸ¨2, "lf", âŸ¨âŸ©âŸ©      # linker flags
  âŸ¨2, "LDFLAGS", âŸ¨âŸ©âŸ© # more linker flags (identical to lf)
  âŸ¨2, "rm_f", âŸ¨âŸ©âŸ©    # forcibly remove C compiler flag(s)
  âŸ¨2, "rm_lf", âŸ¨âŸ©âŸ©   # forcibly remove linker flag(s)
  
  # also define the default OUTPUT value (default default being "BQN")
  âŸ¨1, "shared", 0âŸ©   # build a shared library; OUTPUT = "libcbqn.[so|dylib]"
  âŸ¨1, "wasi", 0âŸ©     # build with WASI;        OUTPUT = "BQN.wasm"
  âŸ¨1, "emcc", 0âŸ©     # build with emscripten;  OUTPUT = ".", is used as a directory
  
  âŸ¨1, "FFI", @âŸ©       # enable FFI through libffi; default â‰¡ Â¬wasiâˆ¨emcc
  âŸ¨1, "pkgconfig", 1âŸ© # attempt to use pkg-config to find libffi inclusion flags
  âŸ¨1, "singeli", 0âŸ©   # enable Singeli
  âŸ¨1, "REPLXX", 0âŸ©    # enable replxx
  # TODO options for forcing around the bytecode/singeli/replxx directories
  
  # CBQN toggles
  âŸ¨1, "rtverify", 0âŸ©
  âŸ¨1, "heapverify", 0âŸ©
  
  âŸ¨1, "c", 0âŸ©      # disable some default flags
  âŸ¨1, "O3", @âŸ©     # -O3; default â‰¡ Â¬c
  âŸ¨1, "g", @âŸ©      # -g; default â‰¡ debug
  âŸ¨1, "native", 0âŸ© # -march=native & use native arch as lower & upper bound for Singeli
  âŸ¨1, "debug",  0âŸ© # -DDEBUG & -g
  
  âŸ¨0, "CXX", "c++"âŸ© # C++ compiler (for replxx)
  âŸ¨2, "REPLXX_FLAGS", âŸ¨"-std=c++11", "-Os"âŸ©âŸ© # default replxx C++ build flags
âŸ©

Log â† â€¢Out
_verboseLog â† {ğ”½_ğ•£:âŠ¢}
onExitList â† âŸ¨âŸ©
OnExit â† {ğ•Š: {ğ•@}Â¨ onExitList}
_assert_ â† { ğ”¾ğ•©?ğ•©; Log ğ•¨ğ”½ğ•© â‹„ OnExit@ â‹„ â€¢Exit 1}

SepArgs â† {' ' ((Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜â‰ âŠ”âŠ¢) ğ•©}
Lowercase â† {ğ•© - (-Â´"Aa")Ã—(ğ•©â‰¥'A')âˆ§ğ•©â‰¤'Z'}

getOpt â† {
  args â† Ã—âˆ˜â‰ Â¨âŠ¸/ â€¢args
  [ot, on0, od] â† â‰>opts
  on â† LowercaseÂ¨ on0
  ot1 â† 1=ot
  ot2 â† 2=ot
  
  s1 â† âŠ‘âˆ˜âŠâŸœ'='Â¨ args # start of =
  hs â† s1<â‰ Â¨args     # has value
  fl â† hsâˆ§'+'=(0âŒˆs1-1)âŠ‘Â¨args # is appended flag, i.e. "f+=a b c"
  s0 â† s1-fl         # end of key
  ks â† s0â†‘Â¨args      # keys
  ks LowercaseÂ¨â†©     # lowercase keys
  vs â† (1+s1)â†“Â¨args  # values
  {ğ•Š: "Unknown option -- "âˆ¾âŠ‘(Â¬ksâˆŠon)/ks}_assert_(âˆ§Â´) ksâˆŠon
  
  ci â† onâŠks # index in option specification
  {ğ•Š: âˆ¾âŸ¨"Error: Unexpected '+=' for '",ksâŠ‘ËœâŠ‘/Â¬ğ•©,"'"âŸ©}_assert_(âˆ§Â´) (ciâŠot2)âˆ¨Â¬fl
  
  Gr â† {(â‰ ot)â†‘ciâŠ”ğ•©}
  gvs â† Gr vs # values for each option
  {ğ•Š: âˆ¾âŸ¨"Error: Multiple values given for '",onâŠ‘ËœâŠ‘/Â¬ğ•©,"'"âŸ©}_assert_(âˆ§Â´) ot2âˆ¨1â‰¥â‰ Â¨gvs
  
  {ğ•Š: âˆ¾âŸ¨"Error: Expected value to be provided for ",âŠ‘ğ•©/ksâŸ©}_assert_(Â¬âˆ¨Â´) (Â¬ciâŠot1) âˆ§ Â¬hs
  
  # f='a b' f+='c d' â†’ "a" "b" "c d"
  gvs â†© (Gr fl) (âˆ¾{ğ•¨?â‹ˆğ•©;Ã—â‰ ğ•©?SepArgs ğ•©;â‹ˆâŸ¨âŸ©}Â¨)Â¨âŒ¾(ot2âŠ¸/) gvs
  # map toggles to their actual values, error on invalid
  gvs â†© on {ğ•¨{ğ•Š: âˆ¾âŸ¨"Error: Invalid value for '",ğ•¨,"'"âŸ©}_assert_âŠ¢ âˆ§Â´ğ•©âˆŠ""â€¿"0"â€¿"1" â‹„ â‰ â—¶âŠ¢â€¿(â‹ˆ"0"â‰¢âŠ‘) ğ•©}Â¨âŒ¾(ot1âŠ¸/) gvs
  
  gvs â†© ((Â¬ot2) â‹ˆâˆ˜âŠ¢âŸâŠ£Â¨ od) {Ã—â‰ ğ•©?ğ•©;ğ•¨}Â¨ gvs # map in defaults
  
  gvs â†© (Â¬ot2) â‹ˆâ¼âˆ˜âŠ¢âŸâŠ£Â¨ gvs # disclose options with only one expected result
  
  # â€¢Show [ks, fl, hs, ci, vs]
  # â€¢Show {ğ•©/ËœÃ—(â‰ 1âŠ‘âŠ¢)Ë˜ğ•©} â‰[on, gvs]
  {(âŠ‘onâŠ<Lowercase ğ•©)âŠ‘gvs}
}

SH â† {
  câ€¿oâ€¿e â† â€¢SHâŠ{ğ•Š: ğ•© {ğ•Š: âˆ¾âŸ¨"Error: Failed to spawn ",âŠ‘ğ•¨âŸ©}_assert_âŠ¢ 0} ğ•©
  LogâŸ(Ã—â‰ ) e
  ğ•© {ğ•Š: âˆ¾âŸ¨"Error: ",âŠ‘ğ•¨," exited with error code ",â€¢Repr ğ•©âŸ©}_assert_(0=âŠ¢) c
  o
}

rootDir â† â€¢file.ParentâŸ2 â€¢file.path
AtRoot â† rootDirâŠ¸â€¢file.At

po â† { # parsed options
  âŸ¨
    verbose, j, rebuildAll, output,
    os, arch, native,
    emcc, wasm, replxx, singeli,
    bytecodeDir, replxxDir, singeliDir,
    CBQNc, REPLXXc, Linker
  âŸ©â‡
  
  custom â† GetOpt "c"
  DOpt â† {@âŠ¸â‰¡â—¶âŸ¨âŠ¢,ğ•¨âŸ© GetOpt ğ•©}
  j â‡ â€¢BQN GetOpt "j"
  rebuildAll â‡ GetOpt "rebuild"
  {ğ•Š: _verboseLog â†© {Logğ•¨ğ”½ğ•©â‹„ğ•©}}âŸâŠ¢ verboseâ‡GetOpt "verbose"
  
  Max1 â† {ğ•© {ğ•Š: aâ€¿bâ†2â†‘ğ•©/ğ•¨ â‹„ âˆ¾âŸ¨"Error: '",a,"' and '",b,"' cannot both be enabled"âŸ©}_assert_(1â‰¥+Â´) GetOptÂ¨ ğ•©}
  Max1 "REPLXX"â€¿"shared"â€¿"wasi"â€¿"emcc"
  
  
  shared â† GetOpt "shared"
  native â‡ GetOpt "native"
  emcc â‡ GetOpt "emcc"
  wasi â† GetOpt "wasi"
  wasm â‡ wasiâˆ¨emcc
  
  cc â† {emcc? "emcc"; "clang"} DOpt "CC"
  cxx â† GetOpt "CXX"
  ffi â† (Â¬wasm) DOpt "FFI"
  debug â† GetOpt "debug"
  singeli â‡ GetOpt "singeli"
  replxx â‡ GetOpt "REPLXX"
  
  uname â† âŠ¢â—¶""â€¿{ğ•Š: Lowercase 1âŠ‘â€¢SHâŠ1â€¿""â€¿"" "uname"â€¿"-sm"} âˆ§Â´ (@â‰¡GetOpt)Â¨ "os"â€¿"arch"
  InUname â† {ğ•Š: âˆ¨Â´ ğ•©â·uname}
  
  os â‡ Lowercase {InUname"linux"? "linux"; InUname"darwin"? "macos"; InUname"bsd"? "bsd"; "linux"} DOpt "os"
  linuxâ€¿bsdâ€¿macos â† osâŠ¸â‰¡Â¨ {ğ•Š: "Error: Unsupported OS; options:"âˆ¾1â†“âˆ¾", "âŠ¸âˆ¾Â¨ğ•©}_assert_(âŠ‘os<âŠ¸âˆŠâŠ¢) "linux"â€¿"bsd"â€¿"macos"
  
  arch â‡ {'-'Â¨âŒ¾(('_'=ğ•©)âŠ¸/)ğ•©} Lowercase {InUname"x86_64"? "x86-64"; âˆ¨Â´InUnameÂ¨"aarch64"â€¿"arm64"? "aarch64"; "generic"} DOpt "arch"
  {ğ•Š: "Error: Unsupported arch; options:"âˆ¾1â†“âˆ¾", "âŠ¸âˆ¾Â¨ğ•©}_assert_(âŠ‘arch  <âŠ¸âˆŠâŠ¢) "x86-64"â€¿"aarch64"â€¿"generic"
  
  {ğ•Š: "Error: Cannot use Singeli on x86-64 without 'native'"}_assert_Â¬ (archâ‰¡"x86-64")âˆ§singeliâˆ§Â¬native
  {ğ•Š: "Error: Cannot use Singeli on generic arch"}_assert_Â¬ singeli âˆ§ archâ‰¡"generic"
  
  output â‡ GetOpt "OUTPUT"
  output â†© â€¢wdpathâ€¢file.At {ğ•Š:
    wasi? "BQN.wasm";
    emcc? ".";
    shared? "libcbqn." âˆ¾ macosâŠ‘"so"â€¿"dylib";
    "BQN"
  }âŸ(""â‰¡âŠ¢) output
  
  exportSymbols â† ffiâˆ¨shared
  
  GetLibs â† { ğ•Š:
    getLibs â†© {
      Â¬ffi? âŸ¨âŸ¨âŸ©,âŸ¨âŸ©âŸ©;
      GetOpt "pkgconfig"? 0=âŠ‘ â€¢SHâŠ1 "pkg-config"â€¿"--exists"â€¿"libffi"?
        {SepArgs Â¯1â†“SHâŸ¨"pkg-config",ğ•©,"libffi"âŸ©}Â¨ âŸ¨"--cflags", "--libs"âŸ©;
      âŸ¨âŸ¨âŸ©, âŸ¨"-lffi"âŸ©âŸ©
    }
  }
  
  SubmoduleDir â† "build"âŠ¸â€¢file.AtâŸ(@â‰¢âŠ¢) {ğ•¨â‰¡0?@; â€¢file.Exists râ†AtRoot "build"â€¢file.At ğ•©âˆ¾"Local"? r; ğ•©âˆ¾"Submodule"}
  LogDir â† {ğ•©â‰¡@? ğ•¨âˆ¾": not used"; ğ•¨âˆ¾" directory: "âˆ¾AtRoot ğ•©}_verboseLog
  bytecodeDir â‡ 1       SubmoduleDir "bytecode" â‹„ "Bytecode" LogDir bytecodeDir
  replxxDir   â‡ replxx  SubmoduleDir "replxx"   â‹„ "REPLXX" LogDir replxxDir
  singeliDir  â‡ singeli SubmoduleDir "singeli"  â‹„ "Singeli" LogDir singeliDir
  {ğ•Š: "Output location: "âˆ¾ğ•©}_verboseLog output
  
  CBQNc â‡ { ğ•Š:
    isClang â† âˆ¨Â´"clang"â·SH ccâ€¿"--version" # TODO exclude from hash?
    args â† âŸ¨
      cc,
      "-std=gnu11",
      "-Wall", "-Wno-unused-function",
      "-fms-extensions", "-ffp-contract=off", "-fno-math-errno", "-fvisibility=hidden",
      "-DBYTECODE_DIR="âˆ¾â€¢file.Name bytecodeDir,
      "-DSINGELI="âˆ¾â€¢Repr singeli,
      "-DFFI="âˆ¾â€¢Repr 2Ã—ffi
    âŸ©
    argsâˆ¾â†© isClangâŠ‘âŸ¨
      âŸ¨"-Wno-parentheses"âŸ©
      âŸ¨"-Wno-microsoft-anon-tag", "-Wno-bitwise-instead-of-logical", "-Wno-unknown-warning-option"âŸ©
    âŸ©
    argsâˆ¾â†© 0âŠ‘GetLibs@
    
    argsâˆ¾â†© GetOpt "f"
    argsâˆ¾â†© GetOpt "CCFLAGS"
    argsâˆ¾â†© (singeliâˆ§archâ‰¡ "x86-64") / âŸ¨"-DSINGELI_X86_64"âŸ©
    argsâˆ¾â†© (singeliâˆ§archâ‰¡"aarch64") / âŸ¨"-DSINGELI_NEON"âŸ©
    argsâˆ¾â†© (               wasm) / âŸ¨"-DWASM"âŸ©
    argsâˆ¾â†© (               wasi) / âŸ¨"-DWASI", "-DNO_MMAP", "-DCATCH_ERRORS=0", "-D_WASI_EMULATED_MMAN", "--target=wasm32-wasi"âŸ©
    argsâˆ¾â†© (               emcc) / âŸ¨"-DEMCC", "-O3"âŸ©
    argsâˆ¾â†© (             replxx) / âŸ¨"-DUSE_REPLXX", "-I"âˆ¾replxxDirâˆ¾"/include"âŸ© # TODO maybe move to main.c only, and have it be in its own separate cache dir, so that adding replxx doesn't recompile everything?
    argsâˆ¾â†© (     debug DOpt "g") / âŸ¨"-g"âŸ©
    argsâˆ¾â†© ((Â¬custom) DOpt "O3") / âŸ¨"-O3"âŸ©
    argsâˆ¾â†© (             native) / âŸ¨"-march=native"âŸ©
    argsâˆ¾â†© (              debug) / âŸ¨"-DDEBUG"âŸ©
    argsâˆ¾â†© (     GetOpt "color") / âŸ¨isClangâŠ‘"-fdiagnostics-color=always"â€¿"-fcolor-diagnostics"âŸ© # TODO exclude from hash?
    argsâˆ¾â†© (  GetOpt "rtverify") / âŸ¨"-DRT_VERIFY", "-DEEQUAL_NEGZERO"âŸ©
    argsâˆ¾â†© (GetOpt "heapverify") / âŸ¨"-DHEAP_VERIFY"âŸ©
    argsâˆ¾â†© (      exportSymbols) / âŸ¨"-DCBQN_EXPORT"âŸ©
    argsâˆ¾â†© (             shared) / âŸ¨"-DCBQN_SHARED", "-shared", "-fPIC"âŸ©
    args â†© args (Â¬âˆ˜âˆŠ/âŠ£) GetOpt "rm_f"
    {"CBQN C compiler: "âˆ¾â€¢Repr ğ•©} _verboseLog args
    cbqnc â†© args
  }
  
  REPLXXc â‡ { ğ•Š:
    args â† âŸ¨cxx, "-DREPLXX_STATIC=1", "-I"âˆ¾replxxDirâˆ¾"/include"âŸ©
    argsâˆ¾â†© GetOpt "REPLXX_FLAGS"
    {"REPLXX C++ compiler: "âˆ¾â€¢Repr ğ•©} _verboseLog args
    replxxc â†© args
  }
  
  Linker â‡ { ğ•Š:
    args â† âŸ¨{replxx? cxx; cc} DOpt "LD", "-lm"âŸ©
    argsâˆ¾â†© 1âŠ‘GetLibs@
    argsâˆ¾â†© (Â¬bsd) / âŸ¨"-ldl"âŸ©
    argsâˆ¾â†© GetOpt "lf"
    argsâˆ¾â†© GetOpt "LDFLAGS"
    argsâˆ¾â†© (                  wasi) / âŸ¨"-lwasi-emulated-mman", "--target=wasm32-wasi", "-Wl,-z,stack-size=8388608", "-Wl,--initial-memory=67108864"âŸ©
    argsâˆ¾â†© (                  emcc) / âŸ¨"-s", "EXPORTED_FUNCTIONS=_main,_cbqn_runLine,_cbqn_evalSrc", "-s", "EXPORTED_RUNTIME_METHODS=ccall,cwrap", "-s", "ALLOW_MEMORY_GROWTH=1"âŸ©
    argsâˆ¾â†© (         exportSymbols) / âŸ¨"-rdynamic"âŸ©
    argsâˆ¾â†© ( linux âˆ§ archâ‰¡"x86-64") / âŸ¨"-no-pie"âŸ©
    args â†© args (Â¬âˆ˜âˆŠ/âŠ£) GetOpt "rm_lf"
    {"linker: "âˆ¾â€¢Repr ğ•©} _verboseLog args
    linker â†© args
  }
  
  {ğ•Š: CBQNc@ â‹„ REPLXXcâŸreplxx @ â‹„ Linker@}âŸâŠ¢ verbose
}

Hash â† {(32â†‘âˆ¾"0a"+â†•Â¨10â€¿26)âŠËœ{ğ•¨+2Ã—ğ•©}Ë5â€¿âŒŠâ¥Š32â€¿1â€¢bit._castâˆ¾(â†•4)â€¢HashÂ¨<ğ•©}

MkDir â† {â€¢file.Existsğ•©?@; â€¢file.CreateDirğ•©}

allObjDir â† "build/obj2"
MkDir AtRoot allObjDir

isFileTheSame â† {
  ksâ€¿vs â† âŸ¨âŸ©â€¿âŸ¨âŸ©
  {
    i â† âŠ‘ksâŠ<ğ•¨
    i<â‰ ks? ğ•© â‰¡ iâŠ‘vs;
    ksâˆ¾â†© <ğ•¨
    vsâˆ¾â†© <tâ†â€¢file.Modified ğ•¨
    ğ•© â‰¡ t
  }
}
updateSubmodule â† {
  done â† âŸ¨âŸ©
  {
    ğ•©â‰¡@? @;
    "Local"â‰¡Â¯5â†‘ğ•©? @;
    âŠ‘ğ•©<âŠ¸âˆŠdone? @;
    doneâˆ¾â†© <ğ•©
    SH âŸ¨"git", "-C", rootDir, "submodule", "update", "--init", AtRoot ğ•©âŸ©
  }
}

# gets/creates a directory of cacheable objects; key is the unique identifier of when it can be reused
GetCache â† { ğ•Š basenameâ€¿descâ€¿key:
  hash â‡ Hash key
  folder â‡ allObjDirâ€¢file.At basenameâˆ¾"-"âˆ¾hash
  MkDir AtRoot folder
  
  File â‡ folderâŠ¸â€¢file.At
  {ğ•Š: descâˆ¾": "âˆ¾AtRootğ•©} _verboseLog folder
  
  dataPath â† AtRoot File "data"
  prevKsâ€¿prevVs â† â€¢file.Existsâ—¶âŸ¨âŸ¨âŸ©â€¿âŸ¨âŸ©, {Deserialize âŸ¨8â€¿'c',8âŸ©â€¢bit._cast â€¢FBytes ğ•©}âŸ© dataPath
  
  IsUpToDate â‡ { ğ•Š:
    i â† âŠ‘prevKsâŠ<ğ•©
    i<â‰ prevKs?
      {@:0; âˆ§Â´ AtRootâŠ¸IsFileTheSameÂ´Â¨ğ•©} iâŠ‘prevVs;
    0
  }
  newKsâ€¿newVs â† âŸ¨âŸ©â€¿âŸ¨âŸ©
  Update â‡ {keyğ•Šdata: newKsâˆ¾â†© <key â‹„ newVsâˆ¾â†© <data} # dataâ‰¡@ means failed to build
  onExitListâˆ¾â†© {{ ğ•Š:
    jKs â† newKsâˆ¾prevKs
    jVs â† newVsâˆ¾prevVs
    dataPath â€¢FBytes âŸ¨8,8â€¿'c'âŸ©â€¢bit._cast Serialize (<âˆŠjKs) /Â¨ jKsâ€¿jVs
  }âŸ{ğ•Š: 0â‰ â‰ newKs}}
}

ruleKsâ€¿ruleVs â† âŸ¨âŸ©â€¿âŸ¨âŸ©
AddRule â† { ğ•Š cacheâ€¿cacheKeyâ€¿dstâ€¿GetCMDâ€¿dispâ€¿customDeps:
  ruleKsâˆ¾â†© <dst
  ruleVsâˆ¾â†© {
    cache â‡ cache
    cacheKey â‡ cacheKey
    disp â‡ disp
    CMD â‡ GetCMD
    ruleDeps â‡ customDeps
  }
}

# dependency resolution & thread management
Run â† { ğ•Š:
  ruleDeps â† {ğ•©.ruleDeps}Â¨ ruleVs
  ruleSrcs0 â† ruleKsâŠâˆ¾ruleDeps
  ! âˆ§Â´ ruleSrcs0<â‰ ruleKs
  ruleSrcs â† ((â‰ âˆ¾Ëœâ‰ Â¨/â†•âˆ˜â‰ )ruleDeps) âŠ” ruleSrcs0
  req â† âŸ¨âŸ©
  ruleN â† 0Â¨ ruleKs # number of children (i.e. how many have this in their ruleP list)
  ruleP â† âŸ¨âŸ©Â¨ ruleKs # parent rules (i.e. which ones require this)
  rebuildAll â† po.rebuildAll
  
  Require â† {
    v â† ğ•©âŠ‘ruleVs
    rebuild â† rebuildAll
    chi â† ğ•©âŠ‘ruleSrcs
    chr â† RequireÂ¨ chi
    rebuildâˆ¨â†© âˆ¨Â´ chr
    # rebuildâˆ¨â†© Â¬â€¢file.Exists AtRoot ğ•©âŠ‘ruleKs # not really needed unless someone deletes a specific file without deleting the data file
    rebuildâˆ¨â†© Â¬v.cache.IsUpToDate v.cacheKey
    {
      ruleN (+Â´chr)âŠ¸+âŒ¾(ğ•©âŠ¸âŠ‘)â†©
      ruleP âˆ¾âŸœğ•©Â¨âŒ¾((chr/chi)âŠ¸âŠ)â†©
      reqâˆ¾â†© ğ•©
    }âŸrebuild ğ•©
    rebuild
  }
  anyRebuilt â† Require âŠ‘ruleKsâŠ<ğ•©
  
  left â† (reqâŠruleN=0)/req
  
  RequestJob â† { ğ•Š:
    0=â‰ left? @;
    (leftâ†“Ëœâ†© Â¯1) âŠ¢ Â¯1âŠ‘left
  }
  
  FinishJob â† { iğ•Štb:
    v â† iâŠ‘ruleVs
    LogâŸ(Ã—â‰ ) 1âŠ‘tb
    âŠ¢â—¶âŸ¨
      { ğ•Š:
        v.cacheKey v.cache.Update @
      }
      { ğ•Š:
        v.cacheKey v.cache.Update 3âŠ‘tb
        ps â† iâŠ‘ruleP
        ruleN -âŸœ1âŒ¾(psâŠ¸âŠ)â†©
        leftâˆ¾â†© (0=psâŠruleN)/ps
      } 
    âŸ© âŠ‘tb
    âŠ‘tb
  }
  
  threads â† Spawnâˆ˜(â€¢file.At "runner.bqn")Â¨ â†•(â‰ req)âŒŠpo.j
  work â† âŸ¨âŸ©
  free â† threads
  Ts â† {ğ•©.t}Â¨
  
  storedOut â† âŸ¨âŸ©
  Log â†© {storedOutâˆ¾â†© <ğ•©âˆ¾@+10}
  # Log â†© {ğ•Š:1}
  currLive â† âŸ¨âŸ©
  e â† @+27
  UpdateLive â† {
    â€¢term.OutRaw (âˆ¾(0âŒˆÂ¯1+â‰ currLive)â¥Š<(eâˆ¾(@+13)âˆ¾"[0K"âˆ¾eâˆ¾"[1F")) âˆ¾ (â€¢ToUTF8 âˆ¾storedOut) âˆ¾ 1â†“âˆ¾((@+10)âˆ¾â€¢ToUTF8)Â¨ ğ•©
    â€¢term.Flush @
    currLive â†© ğ•©
    storedOut â†© âŸ¨âŸ©
  }
  FmtTime â† {{(""â‰¡â—¶âŠ¢â€¿"0" Â¯1â†“ğ•©)âˆ¾'.'âˆ¾Â¯1â†‘ğ•©} â€¢Repr âŒŠ0.5+ 10Ã—ğ•©}
  onExitListâˆ¾â†© {{ğ•Š: UpdateLive âŸ¨âŸ©}}
  
  tmap â† âŸ¨âŸ© # threads in the order they're displayed on-screen (dynamically calculated so that if there's only ever only one job in parallel, there are no pointless empty lines)
  doneCount â† 0
  stopping â† 0
  Fail â† {stoppingâ†©1 â‹„ Log ğ•©}
  DoneLine â† {ğ•Š: âˆ¾âŸ¨â€¢Repr doneCount, "/", â€¢Repr â‰ reqâŸ©}
  { ğ•Š:
    {ğ•Š:
      t â† Â¯1âŠ‘free â‹„ freeâ†“Ëœâ†© Â¯1
      
      i â† RequestJob@ â‹„ vâ†iâŠ‘ruleVs
      t.Request v.CMD@
      workâˆ¾â†© {tâ‡t, iâ‡i, vâ‡v, t0â‡â€¢MonoTime@}
      
    }â€¢_while_{ğ•Š: âˆ§Â´0<â‰ Â¨ leftâ€¿free}âŸÂ¬ stopping
    
    t1 â† â€¢MonoTime@
    tmap â†© â·tmapâˆ¾Ts work
    UpdateLive (<DoneLine@)âˆ¾{
      ğ•©â‰¡â‰ work? "";
      o â† ğ•©âŠ‘work
      âˆ¾âŸ¨"[", FmtTime t1-o.t0, "] ", o.v.dispâŸ©
    }Â¨ (Ts work) âŠtmap
    
    dm â† 0.1 WaitForOne Ts work
    lm â† Â¬dm
    {ğ•Š: Fail "Error: Fork died" â‹„ dmâ€¿lmâˆ§â†©<dmâ‰ Â¯1}âŸâŠ¢ âˆ¨Â´dm=Â¯1
    done â† dm/work
    work â†© lm/work
    {ğ•©.i FinishJob ğ•©.t.Take@? doneCount+â†©1; Fail "Error: During '"âˆ¾ğ•©.v.dispâˆ¾"'"}Â¨ done
    freeâˆ¾â†© Ts done
  }â€¢_while_{ğ•Š: (0<â‰ work) âˆ¨ (Â¬stopping)âˆ§0<â‰ left}@
  
  Log âˆ¾âŸ¨DoneLine@, " in ", FmtTime t0g-Ëœâ€¢MonoTime@, "s", stopping/"; failed to build"âŸ©
  
  Â¬stopping
}


MakeCCInv â† { ğ•Š GetArgsâ€¿Initâ€¿cacheâ€¿idâ€¿srcâ€¿customDeps: # src should be CBQN-base-dir-relative, so that cache doesn't store 
  key â‡ id
  dst â‡ cache.File keyâˆ¾".o"
  GetCMD â† { ğ•Š:
    Init @
    dep â† AtRoot cache.File idâˆ¾".d"
    âŸ¨"sh", rootDir, (GetArgs@)âˆ¾âŸ¨"-MT", "o", "-MMD", "-MF", dep, "-o", AtRoot dst, "-c", srcâŸ©, depâŸ©
  }
  AddRule âŸ¨cache, key, dst, GetCMD, â€¢file.Name src, customDepsâŸ©
}

MakeSingeliInv â† { ğ•Š argsâ€¿Initâ€¿cacheâ€¿idâ€¿srcâ€¿customDeps: # src should be CBQN-base-dir-relative, so that cache doesn't store 
  key â‡ id
  dst â‡ cache.File keyâˆ¾".c"
  GetCMD â† { ğ•Š:
    Init @
    dep â† AtRoot cache.File idâˆ¾".d"
    âŸ¨"singeli", rootDir, AtRoot dst, AtRoot po.singeliDir, args, AtRoot src, depâŸ©
  }
  AddRule âŸ¨cache, key, dst, GetCMD, â€¢file.Name src, customDepsâŸ©
}

MakeLinkerInv â† { ğ•Š GetArgsâ€¿cacheâ€¿nameâ€¿srcs:
  dst â‡ cache.File name
  GetCMD â† { ğ•Š:
    args â† GetArgs@
    âŸ¨"sh", rootDir, âŸ¨âŠ‘args, "-o", dstâŸ©âˆ¾srcsâˆ¾1â†“args, @âŸ©
  }
  AddRule âŸ¨cache, name, dst, GetCMD, "link", srcsâŸ©
}



# actual CBQN/Singeli/REPLXX definitions
cachedBinâ€¿linkerCache â† {
  Shorten â† {r â† {ğ•©â†“ËœÂ¯1-âŠ‘'.'âŠËœâŒ½ğ•©}Â¨ â€¢file.NameÂ¨ ğ•© â‹„ ! âˆ§Â´ âˆŠr â‹„ r}
  cbqnSrc â† âˆ¾{âŒ½(âŠ‘ğ•©)âŠ¸â€¢file.AtÂ¨ 1â†“ğ•©}Â¨ âŒ½âŸ¨
    âŸ¨"src/builtins/", "arithd.c", "arithm.c", "cmp.c", "sfns.c", "squeeze.c", "select.c", "slash.c", "group.c", "sort.c", "search.c", "selfsearch.c", "fold.c", "scan.c", "md1.c", "md2.c", "fns.c", "sysfn.c", "internal.c", "inverse.c"âŸ©
    âŸ¨"src/core/", "tyarr.c", "harr.c", "fillarr.c", "stuff.c", "derv.c", "mm.c", "heap.c"âŸ©
    âŸ¨"src/", "load.c", "main.c", "rtwrap.c", "vm.c", "ns.c", "nfns.c", "ffi.c"âŸ©
    âŸ¨"src/jit/", "nvm.c"âŸ©
    âŸ¨"src/utils/", "utf.c", "hash.c", "file.c", "mut.c", "each.c", "bits.c"âŸ©
  âŸ©
  singeliMap â† {po.archâ‰¡"aarch64"? ğ•©/Ëœ(1âŠ‘Â¨ğ•©)âˆŠ"cmp"â€¿"bits"â€¿"equal"; ğ•©} âŸ¨
    "src/core/stuff.c"â€¿"equal",        "src/utils/mut.c"â€¿"copy",       "src/utils/bits.c"â€¿"bits"
    "src/builtins/arithd.c"â€¿"dyarith", "src/builtins/cmp.c"â€¿"cmp",     "src/builtins/squeeze.c"â€¿"squeeze"
    "src/builtins/select.c"â€¿"select",  "src/builtins/fold.c"â€¿"fold",   "src/builtins/scan.c"â€¿"scan"
    "src/builtins/scan.c"â€¿"neq",       "src/builtins/slash.c"â€¿"slash", "src/builtins/slash.c"â€¿"constrep"
  âŸ©
  objs â† âŸ¨âŸ©
  
  
  
  replxxCache â† {
    Â¬po.replxx? @;
    replxxCache â† GetCache âŸ¨"replxx", "REPLXX object file location", po.REPLXXc@âŸ©
    
    replxxSrc â† (po.replxxDirâ€¢file.At"src")âŠ¸â€¢file.AtÂ¨âŸ¨"ConvertUTF.cpp", "wcwidth.cpp", "conversion.cxx", "escape.cxx", "history.cxx", "prompt.cxx", "replxx.cxx", "replxx_impl.cxx", "terminal.cxx", "util.cxx", "windows.cxx"âŸ©
    objsâˆ¾â†© {ğ•©.dst}Â¨ (Shorten replxxSrc) {MakeCCInv âŸ¨po.REPLXXc, âŠ¢, replxxCache, ğ•¨, ğ•©, âŸ¨âŸ©âŸ©}Â¨ replxxSrc
    
    replxxCache
  }
  
  singeliObjs â† @
  singeliCache â† {
    Â¬po.singeli? @;
    singeliCache â† GetCache âŸ¨"singeli", "Singeli generated code location", âŸ¨po.native, po.archâŸ©âŸ©
    
    # genArithTables
    ga â† "src/singeli/src/genArithTables.bqn"
    gaDefs â† singeliCache.File "arDefs.singeli"
    gaTables â† singeliCache.File "arTables.c"
    AddRule âŸ¨
      singeliCache, "genArithTables",
      gaDefs, # am cheating and only using arDefs.singeli as destination; Â¯\_(ãƒ„)_/Â¯
      {ğ•Š: âŸ¨"runbqn", rootdir, AtRoot ga, AtRootÂ¨ gaDefsâ€¿gaTables, âŸ¨gaâŸ©âŸ©},
      â€¢file.Name ga, âŸ¨âŸ©
    âŸ©
    
    singeliArgs â† âŸ¨"-l", "gen="âˆ¾singeliCache.folderâŸ©âˆ¾{
      po.native? âŸ¨âŸ©;
      "-a" â‹ˆ {"x86-64":"X86_64"; "aarch64":"AARCH64"} po.arch
    }
    singeliObjs â†© {ğ•©.dst}Â¨ {MakeSingeliInv âŸ¨singeliArgs, {ğ•Š:UpdateSubmodule po.singeliDir}, singeliCache, ğ•©, "src/singeli/src/"â€¢file.At ğ•©âˆ¾".singeli", (ğ•©â‰¡"dyarith")/âŸ¨gaDefsâŸ©âŸ©}Â¨ 1âŠ‘Â¨singeliMap
    
    singeliCache
  }
  
  cbqnCache â† {
    cbqnCache â† GetCache âŸ¨"cbqn", "CBQN object file location", âŸ¨po.CBQNc@, {po.singeli? singeliCache.hash; @}âŸ©âŸ©
    ruleDeps â† {
      Â¬po.singeli? âŸ¨âŸ©Â¨ cbqnSrc;
      ((â‰ cbqnSrc) âˆ¾Ëœ cbqnSrcâŠâŠ‘Â¨singeliMap) âŠ” singeliObjs
    }
    
    singeliArgs â† {po.singeli? âŸ¨"-DSINGELI_DIR="âˆ¾â€¢file.Name singeliCache.folderâŸ©; âŸ¨âŸ©}
    objsâˆ¾â†© {ğ•©.dst}Â¨ {aâ€¿bâ€¿c: MakeCCInv âŸ¨po.CBQNcâˆ¾singeliArgsË™, {ğ•Š:UpdateSubmodule po.bytecodeDir â‹„ UpdateSubmodule po.replxxDir}, cbqnCache, a, b, câŸ©}Â¨ <Ë˜â‰[Shorten cbqnSrc, cbqnSrc, ruleDeps] # updates replxx because needs replxx.h
    
    cbqnCache
  }
  
  linkerCache â† GetCache âŸ¨"linker", "linker cached result location", âŸ¨
    po.Linker@,
    cbqnCache.hash,
    {po.replxx? replxxCache.hash; @}
    {po.singeli? singeliCache.hash; @}
  âŸ©âŸ©
  res â† MakeLinkerInv âŸ¨po.Linker, linkerCache, {po.emcc? "BQN.js"; "res"}, objsâŸ©
  
  res.dst â‹ˆ linkerCache
}

outPath â† â€¢wdpath â€¢file.At po.output
success â† Run cachedBin
{ ğ•Š:
  po.emcc?
    SH âŸ¨"cp", AtRoot cachedBin,                   outPath â€¢file.At â€¢file.Name cachedBinâŸ©
    SH âŸ¨"cp", AtRoot linkerCache.File "BQN.wasm", outPath â€¢file.At "BQN.wasm"âŸ©
  ;
    SH âŸ¨"cp", AtRoot cachedBin, outPathâŸ©
}âŸâŠ¢ success

OnExit@
â€¢Exit Â¬success