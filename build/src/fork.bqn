szâ†"u64" â‹„ sszâ†"i64" â‹„ nfdsâ†sz

libc_fork â† @ â€¢FFI "i32"â€¿"fork"
libc_pipe â† @ â€¢FFI "i32"â€¿"pipe"â€¿">&i32"
libc_read â† @ â€¢FFI sszâ€¿"read"â€¿"i32"â€¿"&i8"â€¿sz
libc_write â† @ â€¢FFI sszâ€¿"write"â€¿"i32"â€¿"*i8"â€¿sz
libc_close â† @ â€¢FFI "i32"â€¿"close"â€¿">i32"
libc_poll â† @ â€¢FFI "i32"â€¿"poll"â€¿"&i16"â€¿nfdsâ€¿"i32"

Pipe â† { ğ•Š: readfdâ€¿writefd â‡
  âŸ¨c, readfdâ€¿writefdâŸ© â† Libc_pipe 0â€¿0
  ! c=0
  Write â‡ {Libc_write âŸ¨writefd, ğ•©, â‰ ğ•©âŸ©}
  Read â‡ {nâ€¿b â† Libc_read âŸ¨readfd, ğ•©â¥Š0, ğ•©âŸ© â‹„ !nâ‰¥0 â‹„ nâ†‘b}
}

BiDiFork â† { ğ•Š:
  p1 â† Pipe@
  p2 â† Pipe@
  pid â‡ Libc_fork@
  ! pidâ‰¥0
  parent â‡ pid=0
  CloseWR â† {! Â¬âˆ¨Â´ Libc_closeÂ¨ {ğ•¨.writefdâ€¿ğ•©.readfd}Â´ âŒ½âŸparent ğ•©}
  CloseWR p1â€¿p2
  râ€¿w â‡ âŒ½âŸparent p1â€¿p2
  Readâ€¿readfd â‡ r
  Writeâ€¿writefd â‡ w
  Close â‡ CloseWRâˆ˜p2â€¿p1
}

FFn â† { ğ•Š fn:
  f â† BiDiFork@
  {f.parent? Fn f â‹„ f.Close@ â‹„ â€¢Exit 0; f}
}

WriteAll â† {pğ•Šx: {ğ•©-p.Write ğ•©-âŠ¸â†‘x}â€¢_while_Ã— â‰ x}
_readAll â† {p E _ğ•£ n: âŠ‘âŸ(Â¬=) {vâ†p.Read n-â‰ ğ•© â‹„ 0<â‰ v? ğ•©âˆ¾v; <E"eof"}â€¢_while_(=âˆ§nâ‰ â‰ ) â†•0}

WriteSz â† {
  ğ•¨ WriteAll (32â€¿8â€¢bit._cast â‹ˆâ‰ ğ•©)âˆ¾ğ•©
}
_readSz â† { ğ”½_ğ•£ s:
  r â† s <âˆ˜ğ”½ _readAll 4
  {
    =r? n â† âŠ‘8â€¿32â€¢bit._cast r â‹„ s !_readAll n;
    âŠ‘r
  }
}

Serializeâ€¿Deserialize â† â€¢Import "serialize.bqn"

c_make â† 1
c_request â† 2
c_take â† 3
c_one â† 4

control â† FFn {{ ğ•Š control:
  pidsâ€¿procs â† â‹ˆËœâŸ¨âŸ©
  {ğ•Š:
    tyâ€¿cmd â† Deserialize â€¢Exit _readSz control
    
    tyâ—¶âŸ¨ !
      { ğ•Šprogram: # c_make
        p â† FFn {{ ğ•Š p:
          f â† âŸ¨â€¢file.Parent program, â€¢file.Name programâŸ© â€¢BQN â€¢FChars program
          {ğ•Š: p WriteSz Serialize F Deserialize â€¢Exit _readSz p}â€¢_while_ 1@
        }}
        control WriteAll 32â€¿8â€¢bit._cast â‹ˆp.pid
        pidsâˆ¾â†© <p.pid
        procsâˆ¾â†© <p
      }
      { ğ•Špidâ€¿data: # c_request
        p â† (âŠ‘pidsâŠpid)âŠ‘procs
        p WriteSz data
      }
      { ğ•Špid: # c_take
        p â† (âŠ‘pidsâŠpid)âŠ‘procs
        control WriteSz !_readSz p
      }
      { ğ•Šlimitâ€¿sel: # c_one
        ms â† limitÃ—1e3
        "poll time limit too large" ! (msâ‰¡âˆ) âˆ¨ ms<2â‹†31
        p â† (pidsâŠsel)âŠprocs
        fds â† {ğ•©.readfd}Â¨ p
        retâ€¿res â† Libc_poll âŸ¨â¥Š âˆ¾âŸœ1â€¿0Ë˜ 32â€¿16â€¢bit._cast â‰Ë˜fds â‹„ â‰ fds â‹„ âˆâŠ¸â‰¡â—¶âŒŠâ€¿Â¯1 msâŸ©
        ! retâ‰¥0
        control WriteSz Serialize {Â¯1Â¨âŒ¾((Â¬ğ•©âˆŠ0â€¿1)âŠ¸/)ğ•©} Â¯1âŠË˜âˆ˜â€¿4â¥Šres
      }
    âŸ© cmd
  }â€¢_while_ 1@
}}
AskControl â† {control WriteSz Serialize ğ•¨â€¿ğ•©}

Spawn â‡ {
  c_make AskControl ğ•©
  pid â† âŠ‘8â€¿32â€¢bit._cast control !_readAll 4
  {
    pidâ‡pid
    Request â‡ {c_request AskControl pidâ‹ˆSerialize ğ•©}
    Take â‡ {ğ•Š: c_take AskControl pid â‹„ Deserialize !_readSz control}
  }
}

# ğ•©: list of spawn results to wait on
# ğ•¨: if present, maximum time to wait; 0 to return immediately
# result: boolean mask of which have finished (if ğ•¨ isn't given, guaranteed to have at least one `1`)
WaitForOne â‡ {
  c_one AskControl âŸ¨ğ•¨âŠ£âˆ â‹„ {ğ•©.pid}Â¨ ğ•©âŸ©
  Deserialize !_readSz control
}
