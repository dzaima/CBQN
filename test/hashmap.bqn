u â† âŒŠ100Ã—(â€¢UnixTime+1|100Ã—â€¢MonoTime)@
roâ† â€¢MakeRand â€¢Show u
R â† ro.Range

err â† 1  # Run operations that should error

Test â† {iter ğ•Š n:
  # Global set of keys that might be used
  keys â† âŠ’âŠ¸(-âŠ¸âˆ¾âŸ(0<âŠ£)Â¨) (RâŸœ15 RÂ¨ 1-Ëœ1e6âŒŠâˆ˜â‹†RâŸœ0) n
  # Which keys are currently set, and count
  c â† +Â´ mask â† 0 = n R 20+R 10
  # Value for key if set
  vals â† ((RâŸœâ‰ âŠâŠ¢)âŸœâŠ¢â€¿Ã·â€¿â¥Šâ€¿â†• {ğ•ğ•©}Â¨ RâŸœ10) n
  
  map â† keys â€¢HashMapâ—‹(maskâŠ¸/) vals
  
  # Single operations and checks
  _er â† { err ? ! 0âˆ˜ğ”½âŠ1 ğ•©âŠ‘keys ; 1 }
  Cnt â† {ğ•Š: ! c â‰¡ map.Count@ }
  Key â† {ğ•Š: ! (mask/keys) â‰¡â—‹âˆ§ map.Keys@ }
  Val â† {ğ•Š: ! (mask/vals) â‰¡â—‹âˆ§ map.Values@ }
  Has â† { ! (ğ•©âŠ‘mask) â‰¡ map.Has ğ•©âŠ‘keys }
  Get â† { ğ•©âŠ‘mask ? ! (ğ•©âŠ‘vals) â‰¡ map.Get ğ•©âŠ‘keys ; map.Get _er ğ•© }
  Set â† { ğ•¨ map.SetËœ ğ•©âŠ‘keys â‹„ vals ğ•¨Ë™âŒ¾(ğ•©âŠ¸âŠ‘)â†© â‹„ mask {c+â†©Â¬ğ•©â‹„1}âŒ¾(ğ•©âŠ¸âŠ‘)â†© â‹„ @ }
  Del â† { ğ•©âŠ‘mask ? map.Delete ğ•©âŠ‘keys â‹„ mask 0âŒ¾(ğ•©âŠ¸âŠ‘)â†© â‹„ c-â†©1 ; map.Delete _er ğ•© }
  
  Selection â† { (ğ•¨â‰¤1)â—¶âŸ¨RÂ·âŒŠ1.5âŠ¸Ã—,ğ•¨âŸ©âŠ¸âŒŠâŠ¸ro.Dealâˆ˜â‰ âŠ¸âŠ ğ•© }
  RandVal â† Râˆ˜100
  ops â† âŸ¨Cnt, Has, Get, Del, (Râˆ˜nâŠ‘valsË™)SetâŠ¢, RandValâŠ¸SetâŸ©
  
  # Larger sets: argument is number of ops (sometimes overridden)
  FullCheck â† Keyâˆ˜Valâˆ˜Cnt
  Deletes  â† { DelÂ¨          ğ•© Selection  mask }
  Restores â† { âŠâŸœvalsâŠ¸(SetÂ¨) ğ•© Selection Â¬mask }
  RandomOps â† (RâŸœâ‰ âŠâŠ¢)âŸœops {ğ•ğ•©}Â¨ RâŸœn
  RandomSame â† Râˆ˜â‰ âŠ¸âŠ‘âˆ˜ops {ğ•ğ•©}Â¨ RâŸœn
  opSets â† FullCheckâ€¿Deletesâ€¿Restoresâ€¿RandomOpsâ€¿RandomSame
  ((RâŸœâ‰ âŠâŠ¢)âŸœopSets {ğ•ğ•©}Â¨ RâŸœ100) iter
}

1e5 Test 1e2
1e4 Test 1e4
