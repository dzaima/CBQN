### WHOLE-FILE-TEST
# â€¢bit tests
helpers â† âŠ‘â€¢args
r â† (helpers.GetRand@)
âŸ¨RandVals, castsâŸ© â† âŸ¨râŸ© helpers.Import "utils.bqn"
widths â† âŠ‘Â¨casts

# Test â€¢bit._cast first
# Convert unsigned width ğ•— to ğ•˜
_cvtu_ â† {
  ğ•—=ğ•˜ ? ğ•© ;
  ğ•—<ğ•˜ ? bâ†2â‹†ğ•— â‹„ +âŸœ(bâŠ¸Ã—)Ëâ‰âˆ˜â€¿(ğ•˜Ã·ğ•—)â¥Šğ•© ;
        bâ†2â‹†ğ•˜ â‹„ â¥Šâ‰>1(-âŠ¸â†“-bÃ—â†“)âŒŠâˆ˜Ã·âŸœbâŸ(â†•1+ğ•—Ã·ğ•˜)ğ•©
}
_bitcast â† { frâ€¿to _ğ•£ ğ•©:
  S â† {ğ•Š:ğ•©+ğ•¨Ã—ğ•©<0; ğ•Šâ¼:ğ•©-ğ•¨Ã—ğ•©â‰¥ğ•¨Ã·2}
  _off â† {(âŠ‘"uci"âŠ1âŠ‘ğ•—)âŠ‘âŸ¨âŠ¢,-âŸœ@,(2â‹†âŠ‘ğ•—)âŠ¸SâŸ©}
  fâ€¿t â† âŠ‘Â¨ğ•—
  to _offâ¼  f _cvtu_ t  fr _off  ğ•©
}

TestCast â† { fâ€¿t ğ•Š len:
  c â† ğ•¨ âŠ casts
  len +â†© (1âŒˆÃ·ËœÂ´âŠ‘Â¨c) | -len  # Round up to exact conversion
  (c _bitcast â‰¡ c â€¢bit._cast) len RandVals f
}
cs â† / 64>widths              # TODO floats
cx â† âŠâŸœ(32â€¿'c'âŠ¸â‰¢Â¨casts)âŠ¸/ cs  # TODO 32-bit char output
ls â† (â†•100) âˆ¾ r.RangeÂ¨âŠ¸+ âŒŠ 100 Ã— â†•âˆ˜âŒˆâŒ¾(1.5âŠ¸â‹†â¼) 100
{cs (â‹ˆ !âˆ˜TestCast ğ•©Ë™)âŒœ cx}Â¨ ls

# Now other â€¢bit operations
OpArgs â† {_bâ€¿Fâ€¿a:
  mâ†(1<a) âŠ‘ {ğ”½1âŠ¸âŠ‘}â€¿{ğ”½Â´}  # Adjust to act on argument list ğ•¨â€¿ğ•©
  {ğ•— _b _m}â€¿(F _m)â€¿a
}
ops â† Â¯1 (âŠ‘Â¨ âŠ” OpArgsâˆ˜â†“Â¨) âŸ¨ # Group by args then int-ness
  #   op fn args int
  â€¢bit._notâ€¿Â¬â€¿1â€¿0
  â€¢bit._andâ€¿âˆ§â€¿2â€¿0
  â€¢bit._or â€¿âˆ¨â€¿2â€¿0
  â€¢bit._xorâ€¿â‰ â€¿2â€¿0
  â€¢bit._negâ€¿-â€¿1â€¿1
  â€¢bit._addâ€¿+â€¿2â€¿1
  â€¢bit._subâ€¿-â€¿2â€¿1
  â€¢bit._mulâ€¿Ã—â€¿2â€¿1
âŸ©
cres â† (widths â‰¤ 32) âˆ§ 'c' â‰  1âŠ‘Â¨casts  # Possible results; TODO floats
TestOps â† { ğ•Š len: # Length in bits
  tz â† +Â´Â¬âˆ¨`2|âŒŠâˆ˜Ã·âŸœ2âŸ(â†•7) len  # Trailing zeros
  
  wxc â† casts âŠËœ wx â† (2 r.Range â‰ )âŠ¸âŠ / cf â† widthsâ‰¤2â‹†tz
  orc â† casts âŠËœ or â† (2 r.Range â‰ )âŠ¸âŠ / cfâˆ§cres
  owâ€¿Â·â€¿xwâ€¿ww â† wd â† (orâˆ¾âŒ½wx) âŠ widths # â€¢bit._*'s ğ•—
  
  alens0 â† len Ã· wwâ€¿xw # argument lengths
  one â† r.Range 3 # 0/1: make ğ•¨/ğ•© extended; 2: keep same-length
  alens1 â† {1â‰¤pâ†(oneâŠ‘wwâ€¿xw)Ã·Ëœow? p; oneâ†©2 â‹„ ğ•©}âŒ¾(oneâŠ¸âŠ‘)âŸ(oneâ‰¤1) alens0 # maybe reduce one argument to a single element
  
  args â† alens1 RandValsÂ¨ wx
  _bc â† â€¢bit._cast
  Test â† { c ğ•Š ops:
    cargs â† wxc {ğ•¨â€¿c _bc ğ•©}Â¨ alens0 â¥ŠÂ¨ args
    mod â† {1:âŠ¢ ; mâ†2â‹†ğ•© â‹„ mâŠ¸|âŒ¾((mÃ·2)âŠ¸+)} âŠ‘c
    Test1 â† { _bâ€¿Fnâ€¿a:
      Â¬ (1=one)âˆ§a=1? # can't test a monadic function with a should-be-extended arg
        got â† ((2+a)â†‘wd)_b args
        exp â† âŸ¨c,1âŠ‘orcâŸ©_bc Mod Fn cargs
        ! gotâ‰¡exp
      ;@
    }
    Test1Â¨ ops
  }
  DropMul â† Â¯1âŠ¸â†“âŸ(32=ow) # Multiplication test may need 64 bits
  âŸ¨1â€¿'u',âŠ‘orcâŸ© TestÂ¨ 0âŠ¸â†‘âŸ(1=ow)âˆ˜DropMulâŒ¾(1âŠ¸âŠ‘) ops
}
(2â‹†0â€¿3â€¿4â€¿5â€¿6) TestOpsâˆ˜Ã—âŒœ ls
