NextIdx â† {iâ†/ğ•© â‹„ (iâˆ¾â‰ ğ•©)âŠËœiâ‹ğ•¨} # for each index ğ•¨, find the index of the next 1 in mask ğ•©
UM â† {(â‰ ğ•¨)â†‘/â¼ğ•©}
Fail â† {â€¢Out ğ•© â‹„ â€¢Exit 1}
Trim â† {((âˆ¨`âŒ¾âŒ½âˆ§âˆ¨`)ğ•©â‰ ' ')/ğ•©}

{ ğ•Š:
  â€¢Out "Usage: test/run.bqn [options | files]"
  â€¢Out "Options:"
  â€¢Out "  lint             Check that every test either is expected to return a specific value, error, or contains a '!'"
  â€¢Out "  slow             Enable slow tests"
  â€¢Out "  noerr            Disable erroring tests (ones expected to, or which contain âŠ)"
  â€¢Out "  heapverify       Disable tests that aren't runnable in heapverify"
  â€¢Out "  debug            Disable tests that aren't runnable in debug"
  â€¢Out "  no-catch         Disable catching errors in tests not expected to error"
  â€¢Out "  update-messages  Auto-update error messages in tests"
  â€¢Out "  ignore-messages  Don't warn about incorrect error messages"
  â€¢Out "  bin-search       Binary search for some property. Next argument should be /[01]*/, with a 1 appended every time the property is matched, and a 0 otherwise"
  â€¢Exit 0
}âŸâŠ¢ (0=â‰ â€¢args) âˆ¨Â´ "help"â€¿"h"â€¿"?"âˆŠ'-'âŠ¸â‰ âŠ¸/Â¨â€¢args

o â† {
  args â† â€¢args
  search â‡ @
  {
    nâ†Â»ğ•©
    search â†© '0'-ËœâŠ‘(n/args)âˆ¾<""
    ! âˆ§Â´searchâˆŠ0â€¿1
    search â†© searchâˆ¾1
    args â†© (Â¬nâˆ¨ğ•©)/args
  }âŸ(âˆ¨Â´) "bin-search"âŠ¸â‰¡Â¨ args
  named â† "run"â€¿"lint"â€¿"update-messages"â€¿"slow"â€¿"ignore-messages"â€¿"noerr"â€¿"heapverify"â€¿"debug"â€¿"no-catch"
  i â† namedâŠargs
  run    â‡ âˆ¨Â´i=0
  lint   â‡ âˆ¨Â´i=1
  update â‡ âˆ¨Â´i=2
  slow   â‡ âˆ¨Â´i=3
  errm   â‡Â¬âˆ¨Â´i=4
  noerr  â‡ âˆ¨Â´i=5
  heapverify â‡ âˆ¨Â´i=6
  debug      â‡ âˆ¨Â´i=7
  noCatch    â‡ âˆ¨Â´i=8
  noerrâˆ¨â†© heapverify
  files â‡ (i=â‰ named)/args
  run â†© update âˆ¨ Â¬âˆ¨Â´lintâ€¿update
}

_catch_ â† {o.noCatch? ğ”½; ğ”½âŠğ”¾}

searchRefine â† {
  searchI â† 0
  {
    o.searchâ‰¡@? ğ•©;
    searchIâ‰¡â‰ o.search? ğ•©;
    1â‰¡â‰ ğ•©? ğ•©;
    SearchRefine (âŒŠ2Ã·Ëœâ‰ ğ•©) ((searchI+â†©1) âŠ¢ searchIâŠ‘o.search)â—¶â†“â€¿â†‘ ğ•©
  }
}

exitCode â† 0
Run â† { ğ•Š testname:
  lns â† â€¢FLines fullfile â† "cases"â€¢file.At filename â† testnameâˆ¾".bqn"
  defkâ€¿defv â† âŸ¨"IS_HEAPVERIFY"âŸ©â€¿âŸ¨"heapverifyâ†"âˆ¾â€¢Repr o.heapverifyâŸ©
  i â† 0
  Pos â† {âˆ¾âŸ¨filename, ":", â€¢Repr 1+ğ•©âŸ©}
  Next â† {ğ•Š: (i+â†©1) âŠ¢ iâŠ‘lns}
  Process â† {
    "%DEF "â‰¡5â†‘ğ•©?
      defkâ€¿defvâˆ¾Â¨â†©<Â¨ {(Process 1â†“ğ•©).str}âŒ¾(1âŠ¸âŠ‘) âŠ‘âˆ˜âŠâŸœ' 'âŠ¸(â†‘â‹ˆâ†“) 5â†“ğ•©
      @
    ;
      "":@
    ;
      '#'â‰¡âŠ‘ğ•©? @
    ;
      "("â‰¡ğ•©?
        Process âˆ¾ âˆ¾âŸœ(@+10)Â¨ Â¯1â†“ âˆ¾âŸœ<âŸœNextâ€¢_while_{")"â‰¢Â¯1âŠ‘ğ•©} âŸ¨Next@âŸ©
    ;
      # insert defs
      si â† /(â‰ ğ•©)â†‘"%USE"â·ğ•©
      mi â† si+5
      ei â† mi NextIdx Â¬ğ•©âˆŠ'_'âˆ¾âˆ¾"0aA"+âŸœâ†•Â¨10â€¿26â€¿26
      g â† (+`+Â´ ğ•©âŠ¸UMÂ¨ siâ€¿miâ€¿ei) âŠ” ğ•©
      pre â† âŠ‘g
      [Â·,uk,post] â† â‰â†‘â€¿3â¥Š1â†“g
      {Fail (Pos i)âˆ¾": Unknown def "âˆ¾âŠ‘ğ•©âŠuk}âŸâ‰  /Â¬ukâˆŠdefk
      str â† pre âˆ¾ âˆ¾((defkâŠuk)âŠdefv) âˆ¾Â¨ post
      
      Flag â† {
        m â† (â‰ str)â†‘ ğ•©â·str
        str /Ëœâ†© Â¬ âˆ¨âŸœÂ»âŸ(Â¯1+â‰ ğ•©) m
        âˆ¨Â´m
      }
      
      {lnâ‡i-1 â‹„ fastâ‡Â¬Flag"%SLOW" â‹„ debugâ‡Â¬Flag"%NDEBUG" â‹„ heapverifyâ‡Â¬Flag"%NHEAPVERIFY" â‹„ strâ‡str}
  }
  tests â† SearchRefine @âŠ¸â‰¢Â¨âŠ¸/ âˆ¾âŸœ<âŸœ(Processâˆ˜Next)â€¢_while_{ğ•Š: iâ‰ â‰ lns} âŸ¨âŸ©
  {ğ•Š: â€¢Out "Narrowed down to test "âˆ¾Pos (âŠ‘tests).ln}âŸâŠ¢ (o.searchâ‰¢@)âˆ§1=â‰ tests
  
  
  tests { ğ•Šns: âŸ¨ln,strâŸ©â†ns
    idx â† âŠ‘strâŠ'%'
    {
      idx â‰¡ â‰ str? âŸ¨ns, "eval", strâŸ©;
      (i2â†idx+1)<â‰ str? '%'â‰¡i2âŠ‘str? âŸ¨ns, "equal", idxâ†‘str, (2+idx)â†“strâŸ©;
      {ğ•Š: Fail (Pos ln)âˆ¾": Unknown test format"}âŸâŠ¢ '!'â‰¢âŠ‘str
      âŸ¨ns, "error", (idx+1)â†“str, 1â†“idxâ†‘strâŸ©
    }
  }Â¨â†©
  
  { ğ•Š d:
    lnâ†(âŠ‘d).ln
    tyâ†1âŠ‘d
    Lint â† {ğ•Š: â€¢Out âˆ¾âŸ¨"Lint: ", Pos ln, ": ", ğ•¨âŸ©}âŸ(Â¬âŠ¢)
    {
      "eval"â‰¡ty? "No check or assert" Lint âˆ¨Â´'!'=2âŠ‘d;
      @
    }
  }Â¨âŸo.lint tests
  
  { ğ•Š:
    badCount â† 0
    badMessage â† 0
    currLn â† 0
    skipped â† 0
    dir â† â€¢file.At "testDir"
    â€¢file.CreateDirâŸ(Â¬â€¢file.Exists) dir
    Bad â† {
      ""ğ•Šğ•©;
      â€¢Out âˆ¾âŸ¨Pos currLn, ": ", ğ•©âŸ©
      â€¢OutÂ¨ "  "âŠ¸âˆ¾Â¨ ğ•¨
      badCount+â†© 1
    }
    ErrMsg â† {ğ•Š: mâ†â€¢CurrentError@ â‹„ {1==m? âˆ§Â´2=â€¢TypeÂ¨m? m; â€¢ReprâŠ"(unrepresentable)" m}}
    Eval â† {âŸ¨dir, âˆ¾âŸ¨testname,"_line_",â€¢Repr currLn+1,".bqn"âŸ©, âŸ¨"arg0",1âŸ©âŸ© â€¢BQN ğ•©}
    EvalS â† â€¢BQNâŠ{ğ•Š: Bad "Bad comparison value" â‹„ "(bad)"}
    toRun â† tests
    toRun {{ğ•©.fast      }âˆ˜âŠ‘Â¨âŠ¸/ğ•©}âŸ(Â¬o.slow)â†©
    toRun {{ğ•©.debug     }âˆ˜âŠ‘Â¨âŠ¸/ğ•©}âŸo.debugâ†©
    toRun {{ğ•©.heapverify}âˆ˜âŠ‘Â¨âŠ¸/ğ•©}âŸo.heapverifyâ†©
    skipped+â†© (â‰ tests)-â‰ toRun
    results â† {
      "eval"â€¿str: {
        o.noerr? âŠ‘'âŠ'âˆŠstr? skipped+â†©1;
        Eval _catch_ {ğ•Š: Bad "Expected success, got error: "âˆ¾ErrMsg@} str
        @
      };
      "error"â€¿strâ€¿exp: {
        o.noerr? skipped+â†©1;
        okâ€¿got â† (1â‹ˆEval)âŠ(0â‹ˆErrMsg) str
        exp â†© EvalSâŸ{Ã—â‰ Trimğ•©} exp
        {
          (gotâ‰¡exp) âˆ§ Â¬ok? @;
          ok? Bad "Expected error, but didn't get one" â‹„ @;
          âŸ¨"Expected: "âˆ¾exp â‹„ "Got:      "âˆ¾gotâŸ© BadâŸo.errm "Wrong error message"
          badMessage+â†© 1
          got
        }
      };
      "equal"â€¿strâ€¿exp: {
        o.noerr? âŠ‘'âŠ'âˆŠstr? skipped+â†©1;
        okâ€¿got â† (1â‹ˆEval)_catch_(0â‹ˆErrMsg) str
        exp â†© EvalS exp
        {
          Â¬ok? Bad "Expected value, but got error: "âˆ¾got;
          got â€¢internal.EEqual exp? @;
          âŸ¨"Expected: "âˆ¾â€¢Repr exp â‹„ "Got:      "âˆ¾â€¢ReprâŠâ€¢Show gotâŸ© Bad "Wrong value"
          @
        }
        @
      }
    }âˆ˜{currLnâ†©(âŠ‘ğ•©).ln â‹„ 1â†“ğ•©}Â¨ toRun
    
    {ğ•Š:
      resâ€¿desc â† ({@â‰¡ğ•©? 0; (Â¬âŠ‘(@+10)âˆŠğ•©) âˆ§ Â¬âˆ¨Â´"TEST FAIL"â·ğ•©}Â¨ results)âŠ¸/Â¨ resultsâ€¿toRun
      0â‰ â‰ res?
        â€¢Out âˆ¾âŸ¨"Update ", â€¢Reprâ‰ res, " entr", (1<â‰ res)âŠ‘"y"â€¿"ies", " in ", filename, "?"âŸ©
        {
          Â¬âŠ‘"yY"âˆŠËœâŠ‘'n'âˆ¾Ëœâ€¢GetLine@? â€¢Out "Not updating.";
          [idxs, upd] â† â‰>res {newğ•ŠâŸ¨âŸ¨lnâŸ©, "error", str, Â·âŸ©: ln â‹ˆ âˆ¾âŸ¨"!", â€¢Repr new, " ", âŠ‘âˆ˜âŠâŸœ'%'âŠ¸â†“ lnâŠ‘lnsâŸ©}Â¨ desc
          "Refusing to write over changed file" ! lns â‰¡ â€¢FLines fullfile
          fullfile â€¢FLines lns {Ã—â‰ ğ•©? â‹ˆâ¼ğ•©; ğ•¨}Â¨ (â‰ lns)â†‘idxsâŠ”upd
          â€¢Out "Updated."
        }
      ;@
    }âŸâŠ¢ o.update
    skipm â† (Ã—skipped)/âˆ¾âŸ¨" (", â€¢Repr skipped, " skipped)"âŸ©
    ran â† (â‰ tests)-skipped
    {
      0=badCount? â€¢Out filenameâˆ¾": "âˆ¾(â€¢Repr ran)âˆ¾" passed!"âˆ¾skipm;
      â€¢Out âˆ¾âŸ¨â€¢Repr ran-badCount, '/', â€¢Repr ran, skipmâŸ© âˆ¾ ((Â¬o.errm)âˆ§Ã—badMessage)/âˆ¾âŸ¨"; ", â€¢Repr badMessage, " mismatched error message", (1â‰ badMessage)/"s"âŸ©âˆ¾skipm
      exitCode â†© 1
    }
  }âŸo.run @
}
RunÂ¨ SearchRefine o.files

â€¢ExitâŸ(0âŠ¸â‰ )âŸ(Â¬o.heapverify) exitCode