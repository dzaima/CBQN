âŸ¨LVâ‡ListVariations, Vâ‡Variation, Iâ‡Info, TYâ‡Type, Refcâ‡RefcâŸ© â† â€¢internal
u â† âŒŠ100Ã—(â€¢UnixTime+1|100Ã—â€¢MonoTime)@

rand â† â€¢MakeRand â€¢Show u
R â† rand.Range
RB â† "Ab" V RâŸœ2 # uniformly random boolean array
RB2 â† {Â¬âŸ(R 2) "Ab" V ğ•© R 1+R 2â‹†R 10} # random boolean array with random uniform probability

rByteVals â† "Ai8"V {ğ•©-256Ã—ğ•©>127} âˆ¾{{2âŠ¸Ã—âŠ¸+ËœÂ´ 8â†‘/â¼ ğ•© â€¢rand.Subset 8}Â¨ â†•9}Â¨â†•20
RByte â† (R (â‰ rByteVals)Ë™)âŠ¸(âŠ‘âŸœrByteVals)
RH â† Râ¥ŠÂ¨RByte # store to a variable to randomize heap by ğ•¨ values, each up to ğ•© bytes
CH â† { # do "var CHâ†©" to a variable assigned to a result of RH
  "heap corruption" ! âˆ§Â´2=RefcÂ¨ ğ•©
  "heap corruption" ! 1 â‰¡ Refc ğ•©
  0
}
rByteVals {! "i8arr" â‰¡ TY ğ•©â¥Šğ•¨}âŒœ â†•10 # â¥Š is dumb for now, but when it realizes that nâ¥Š0 is a bitarr this'll need changing

OrScanBitarr â† {ğ•Š:
 n â† 1 + R 2â‹†R 13
 ! (âˆ¨` â‰¡ âŠ¢âˆ˜âˆ¨`) "Ab" V {ğ•Š: 1âŒ¾((R n)âŠ¸âŠ‘)ğ•©}âŸ2 0â¥ŠËœ n
}Â¨ â†•

PlusScanBitarr â† {ğ•Š:
  a â† RB2 R 2â‹†R 13
  ! (+` â‰¡ âŠ¢âˆ˜+`) a
}Â¨ â†•

BitSlash â† {tyâ€¿dyâ€¿maxğ•Šn:
  f â† dy âŠ‘ âŸ¨/âˆ˜âŠ¢ â‹„ {ğ•©/ty V ğ•¨ R 100}âŸ©
  {ğ•Š:
    # ğ•©âŠ¸{â€¢Show ğ•¨}âŸâŠ¢ 0=10000|ğ•©
    t1â†20 RH 100
    nâ†R max
    xâ†n F nâ†‘RB2 128+n
    t2â†20 RH 100
    xâ†©0 â‹„ t1 CHâ†© â‹„ t2 CHâ†©
  }Â¨â†•n
}

â€¢Show "âˆ¨`bitarr" â‹„   OrScanBitarr 100000
â€¢Show "+`bitarr" â‹„ PlusScanBitarr 100000

â€¢Show "heap corruption of /bit"    â‹„      @â€¿0â€¿200 BitSlash 1000000
â€¢Show "heap corruption of bit/i8"  â‹„  "Ai8"â€¿1â€¿50  BitSlash 1000000
â€¢Show "heap corruption of bit/i16" â‹„ "Ai16"â€¿1â€¿50  BitSlash 1000000
â€¢Show "heap corruption of bit/i32" â‹„ "Ai32"â€¿1â€¿50  BitSlash 1000000
