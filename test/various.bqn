âŸ¨LVâ‡ListVariations, Vâ‡Variation, ClearRefsâ‡ClearRefs, Iâ‡Info, TYâ‡Type, Refcâ‡Refc, EEQâ‡EEqualâŸ© â† â€¢internal
u â† âŒŠ100Ã—(â€¢UnixTime+1|100Ã—â€¢MonoTime)@

rand â† â€¢MakeRand â€¢Show u
âŸ¨RandValsâŸ© â† âŸ¨randâŸ© â€¢Import "utils.bqn"
R â† rand.Range
RB â† "Ab" V RâŸœ2 # uniformly random boolean array
RB2 â† {Â¬âŸ(R 2) "Ab" V ğ•© R 1+R 2â‹†R 10} # random boolean array with random uniform probability

rByteVals â† "Ai8"V {ğ•©-256Ã—ğ•©>127} âˆ¾{{2âŠ¸Ã—âŠ¸+ËœÂ´ 8â†‘/â¼ ğ•© â€¢rand.Subset 8}Â¨ â†•9}Â¨â†•20
RByte â† (R (â‰ rByteVals)Ë™)âŠ¸(âŠ‘âŸœrByteVals)
RH â† "Ai8"âŠ¸VÂ¨ Râ¥ŠÂ¨RByte # store to a variable to randomize heap by ğ•¨ values, each up to ğ•© bytes
CH â† { # do "var CHâ†©" to a variable assigned to a result of RH
  "heap corruption" ! âˆ§Â´2=RefcÂ¨ ğ•©
  "heap corruption" ! 1 â‰¡ Refc ğ•©
  0
}

OrScanBitarr â† {ğ•Š:
 n â† 1 + R 2â‹†R 13
 ! (âˆ¨` â‰¡ âŠ¢âˆ˜âˆ¨`) "Ab" V {ğ•Š: 1âŒ¾((R n)âŠ¸âŠ‘)ğ•©}âŸ2 "Ai8" V 0â¥ŠËœ n
}Â¨ â†•

PlusScanBitarr â† {ğ•Š:
  a â† RB2 R 2â‹†R 13
  ! (+` â‰¡ âŠ¢âˆ˜+`) a
}Â¨ â†•

BitSlash â† {tyâ€¿dyâ€¿maxğ•Šn:
  f â† dy âŠ‘ âŸ¨/âˆ˜âŠ¢ â‹„ {ğ•©/ty V ğ•¨ R 100}âŸ©
  {ğ•Š:
    # ğ•©âŠ¸{â€¢Show ğ•¨}âŸâŠ¢ 0=10000|ğ•©
    t1 â† 20 RH 100
    n  â† R max
    x  â† n F nâ†‘RB2 128+n
    t2 â† 20 RH 100
    xâ†©0 â‹„ t1 CHâ†© â‹„ t2 CHâ†©
  }Â¨â†•n
}

_testConsistent â† { w0 F _ğ•£ x0:
  âˆ§Â´ (âŠ EEQÂ¨1â†“âŠ¢) â¥Šğ•¨ {(ğ•¨ V w0) F (ğ•© V x0)}âŒœâ—‹LV ğ•©? ClearRefs@;
  
  w0 F _ğ•£ x0:
  â€¢Out "Fail for:"
  "ğ•¨: "â€¿"ğ•©: " â€¢Outâˆ˜(âˆ¾âŸœâ€¢Repr)Â¨ ğ•¨â‹ˆğ•©
  tbl â† ğ•¨ {(ğ•¨ V w0) F (ğ•© V x0)}âŒœâ—‹LV ğ•©
  â€¢Show (<âˆ˜âŠ‘â‰¡Â¨âŠ¢) tbl
  â€¢Exit 1
}

Group â† {ğ•Š:
  t â† R 8
  l â† R 10
  x â† l RandVals t
  w â† Â¯1+l R 1+l
  w âŠ”_testConsistent x
  1
}Â¨ â†•

Mod â† {ğ•Š:
  modOptions â† âŸ¨âˆ,Â¯âˆ,0Ã·0âŸ© âˆ¾ âˆ¾âŸœ- 2â‹†â†•34
  {ğ•Š:
    n â† R 2â‹†4+R 6
    w â† Râˆ˜â‰ âŠ¸âŠ‘ modOptions
    x â† -âŸ(R 2) (2â‹†R 34) + (â†•n)-R n
    got â† w|x
    exp â† w|"Ah"V x
    Â¬exp EEQ got?
    â€¢Out "ğ•¨: "âˆ¾â€¢Repr w
    â€¢Out "ğ•©: "âˆ¾(â€¢Repr x)âˆ¾" / "âˆ¾I x
    â€¢Out "exp: "âˆ¾â€¢Repr exp
    â€¢Out "got: "âˆ¾â€¢Repr got
    â€¢Exit 1
    ;@
  }Â¨ â†•ğ•©
}

â€¢Show "powerOfTwo | arr" â‹„ Mod 100000
â€¢Show "âˆ¨`bitarr" â‹„   OrScanBitarr 100000
â€¢Show "+`bitarr" â‹„ PlusScanBitarr 100000

# â€¢Show "heap corruption test of /bit"    â‹„      @â€¿0â€¿200 BitSlash 1000000
# â€¢Show "heap corruption test of bit/i8"  â‹„  "Ai8"â€¿1â€¿50  BitSlash 1000000
# â€¢Show "heap corruption test of bit/i16" â‹„ "Ai16"â€¿1â€¿50  BitSlash 1000000
# â€¢Show "heap corruption test of bit/i32" â‹„ "Ai32"â€¿1â€¿50  BitSlash 1000000

{
  Â¬0 EEQ -0? â€¢Out "Skipping tests requiring !NEEQUAL_NEGZERO";
  â€¢Show "âŠ” consistency" â‹„ Group 10000
}
