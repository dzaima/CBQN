âŸ¨EEqual, ClearRefs, Variation, Squeeze, TypeâŸ© â† â€¢internal
u â† âŒŠ100Ã—(â€¢UnixTime+1|100Ã—â€¢MonoTime)@

r â† â€¢MakeRand â€¢Show u

ntn â† "bit"â€¿"i8"â€¿"i16"â€¿"i32"â€¿"f64"
ntv â† "Ab"â€¿"Ai8"â€¿"Ai16"â€¿"Ai32"â€¿"Af64"
nmin â† 0âˆ¾  -2â‹†Â¯1+8Ã—2â‹†â†•3
nmax â† 1âˆ¾Â¯1+2â‹†Â¯1+8Ã—2â‹†â†•3
int â† 1â€¿1â€¿1â€¿1â€¿0

ctn â† "c8"â€¿"c16"â€¿"c32"
ctv â† "Ac8"â€¿"Ac16"â€¿"Ac32"
cmax â† 1114112âŒŠ2â‹†8Ã—2â‹†â†•3

âŸ¨specF64âŸ© â† âŸ¨râŸ© â€¢Import "utils.bqn"
spec â† specF64âˆ¾{â‡}âˆ¾"aâ‰ğ•¨"âˆ¾<"foo"

# currently tests an array of 0s, with only one outstanding element
Do â† { ğ•Š:
  val â† {r.Rangeâˆ˜â‰ â—¶ğ•©ğ•©} âŸ¨
    {ğ•Š: r.Rangeâˆ˜â‰ âŠ¸âŠ‘ spec}
    {ğ•Š: (Â¯5+r.Range 10) + 2â‹†r.Range 64}
  âŸ©
  base â† 0
  
  len â† 1+r.Range 2â‹†3+r.Range 7
  pos â† r.Range len
  arr â† "Ah" Variation valâŒ¾(posâŠ¸âŠ‘) lenâ¥Š<base
  
  tOutâ€¿tIn â† {
    1=â€¢Type val?
      msk â† ((Â¬int) âˆ¨ valâ‰¡âŒŠval) âˆ§ 1âˆ¾Ëœ (â‰¥âŸœnminâˆ§â‰¤âŸœnmax)val
      âŸ¨1â†‘msk/ntn â‹„ "Ah"â€¿"Af"âˆ¾msk/ntvâŸ©;
    (2â‰¡â€¢Type val) âˆ§ 1â‰¡len?
      msk â† {2â‰¡â€¢Type val? (1â‰¡len) âˆ§ (val-@)<cmax; 0}
      âŸ¨1â†‘msk/ctn â‹„ "Ah"â€¿"Af"âˆ¾msk/ctvâŸ©;
    # else
      âŸ¨"h"â€¿"fill" â‹„ "Ah"â€¿"Af"âŸ©
  }
  tIn â†© {'S'âˆ¾1â†“ğ•©}Â¨âŠ¸âˆ¾ âˆ¾âŸœ"Inc"Â¨âŠ¸âˆ¾ tIn
  
  { 
    arrv â† ğ•© Variation arr
    sq â† Squeeze arrv
    sqt â† Type sq
    sqtâ†©{
         "arr"â‰¡Â¯3â†‘sqt?  Â¯3â†“sqt;
      !"slice"â‰¡Â¯5â†‘sqt â‹„ Â¯5â†“sqt
    }
    Â¬ (arrv EEqual arr) âˆ§ (arrv EEqual sq) âˆ§ (âŠ‘(<sqt) âˆŠ tOut)?
      â€¢Out "Fail:"
      â€¢Show arrv
      â€¢Show sq
      â€¢Show Type sq
      â€¢Show tOutâ€¿ğ•©
      â€¢Exit 1
    ;@
  }Â¨ tIn
  ClearRefs@
}

n0a â† "Af64" Variation 1â†“1â€¿1â€¿Â¯1Ã—Ï€â€¿0â€¿0
n0b â† Squeeze n0a
{
  n0aâ‰¡â—‹Ã·n0b? â€¢Out "Squeeze behavior on negative zero: keep";
             â€¢Out "Squeeze behavior on negative zero: discard"
}

DoÂ¨ â†•100000
