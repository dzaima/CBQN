local {
  def has512 = x86_has512
  def has512e = x86_has512e
  def intrin = x86_intrin
  def intrin_t = x86_intrin_t
  def intrin_i = x86_intrin_i
  def mt{k} = merge{'mask', fmtnat{__max{k,8}}}
  def mr{s} = merge{s, '_mask'}
}

def store_masked_hom{p:*E, m:[l](u1), v:V=[l]E if has512e{V}} = {
  emit{void, intrin_i{V, 'mask_storeu'}, p, m, v}
}

def store{p:*E, v:[k]E if width{E}>=8, vl if any_int{vl} and not (knum{vl} and is_pow2{vl})} = store_masked_hom{p, lowelt_mask{[k]u1, vl}, v}

local def maskop{M=[k](u1), op, ...args} = emit{M, merge{'_k',op,'_',mt{k}}, ...args}
def  __and{a:M=[k](u1), b:M} = maskop{M, 'and', a, b}
def andnot{a:M=[k](u1), b:M} = maskop{M, 'andn', b, a}
def   __or{a:M=[k](u1), b:M} = maskop{M, 'or', a, b}
def  __xor{a:M=[k](u1), b:M} = maskop{M, 'xor', a, b}
def   __ne{a:M=[k](u1), b:M} = maskop{M, 'xor', a, b}
def   __eq{a:M=[k](u1), b:M} = maskop{M, 'xnor', a, b}
def  __not{a:M=[k](u1)} = maskop{M, 'not', a}
def vec_shift_left {a:M=[k](u1), am if int_idx{am, k}} = maskop{M, 'shiftri', a, am}
def vec_shift_right{a:M=[k](u1), am if int_idx{am, k}} = maskop{M, 'shiftli', a, am}
local def real_mask{x:[k](u1) if k<8} = emit{[8]u1, '', x} # in general could have arbitrary bits in the top (esp int_to_mask), but most ops should produce zeroes

def blend_hom{f:V=[k]E, t:V, m:[k](u1)} = emit{V, intrin_i{V, 'mask_blend'}, m, f, t}


# mask conversions
local def mask_int_ty{k} = ty_u{__max{k,8}}
def hom_to_int{x:[k](u1)} = emit{mask_int_ty{k}, merge{'_cvt',mt{k},'_u',fmtnat{__max{k,32}}}, x}
def int_to_mask{[k](u1), x:T if isunsigned{T} and width{T}>=k} = emit{[k]u1, merge{'_cvtu',fmtnat{__max{k,32}},'_',mt{k}}, x}
def int_to_mask{[k](u1), x if int_idx{x, 1<<k}} = emit{[k]u1, merge{'_cvtu',fmtnat{__max{k,32}},'_',mt{k}}, x}
def vec_broadcast{[k](u1), v if (int_idx{v,2} or hastype{v,u1})} = int_to_mask{[k]u1, mask_int_ty{k}~~tail{k} &- u1~~v}

def reinterpret{T, a:M=[l](u1) if isint{T} and l==width{T}} = T~~hom_to_int{a}
def reinterpret{M=[l](u1), a:T if isint{T} and l==width{T}} = int_to_mask{M, a}

local def make_mask{k, vs} = int_to_mask{[k]u1, base{2, vs}}
def vec_make{[k==length{vs}](u1),  ...vs  if all{int_idx{.,2}, vs}} = make_mask{k, vs}
def vec_make{[k==length{vs}](u1), {...vs} if all{int_idx{.,2}, vs}} = make_mask{k, vs}

def top_to_mask{x:V=[k]E if E!=u1 and veci{V}} = emit{[k]u1, mr{intrin{V,'mov',x86_scali{E}}}, x}
def top_to_int{x:V=[_]_ if w512i{V}} = hom_to_int{top_to_mask{x}}
def hom_to_int{x:V=[_]_ if w512i{V}} = top_to_int{x}

def mask_to_hom{V=[l]_, x:[l](u1)} = emit{V, intrin_i{V,'movm'}, x}

def lowelt_mask{[k](u1), n if any_int{n}} = int_to_mask{[k]u1, bzhi{hom_ones{u64}, n}}



# mask tests
local def kortest{a:M=[k](u1), b:M, kind} = emit{u1, merge{'_kortest',kind,'_',mt{k},'_u8'}, a, b}
def any_hom{x:M=[k](u1), y:M} = ~kortest{x, y, 'z'}
def any_hom{x:[k](u1)} = ~kortest{x, x, 'z'}
def all_hom{x:[k](u1) if k>=8} = kortest{x, x, 'c'}
def all_hom{x:[k](u1) if  k<8} = kortest{real_mask{x}, [8]u1~~u8~~zlow{k,0xff}, 'c'}
def any_hom{x:[k](u1), vl if any_int{vl} and not same{vl,k}} = bzhi{promote{u64,hom_to_int{x}}, vl} != 0



# vector tests
def andnz_mask{x:V=[k]E, y:V if has512e{V} and veci{V}} = emit{[k]u1, mr{intrin_i{V, 'test'}}, x, y}
def any_top{x:V=[k]E if w512i{V}} = any_hom{top_to_mask{x}}
def any_hom{x:V=[k]E if w512i{V}} = any_hom{top_to_mask{x}}
def all_top{x:V=[k]E if w512i{V}} = all_hom{top_to_mask{x}}
def all_hom{x:V=[k]E if w512i{V}} = all_hom{top_to_mask{x}}
def and_bit_none{x:V, y:V if w512i{V}} = ~any_hom{andnz_mask{re_el{u8,x}, re_el{u8,y}}}


def vec_shuffle{L=[k]E, x:XV=[_]XE, i:IV if veci{IV} and all_same{each{width,tup{L,XV,IV}}} and (if (width{E}>8) has512e{L} else has512{L, 'VBMI'})} = {
  def SE = primtype{if (width{E}<=16 and not isint{XE}) 'i' else quality{XE}, width{E}}
  def V = [k]SE # vector type to shuffle in
  def T = if (isint{SE} and isint{XE}) XV else V # type hopefully closer to XV but with same intrinsics type V
  XV~~emit{T, intrin_i{V, 'permutexvar'}, i, T~~x}
}

def extract{x:V=[k]E, i if w512{V} and int_idx{i, k}} = {
  def l = 128/width{E}
  extract{extract{[l]E, x, i >> lb{l}}, i % l}
}

def multishift{a:[k](u64), i:V=[(k*8)](u8) if has512{V, 'VBMI'}} = emit{V, intrin_i{V, 'multishift_epi64'}, i, a}

def narrow{DE, x:[k]SE if isint{DE} and quality{DE}==quality{SE} and x86_has512e{[k]SE}} = {
  emit{x86_vec_low{k,DE}, intrin{[k]SE, 'cvtepi', fmtwidth{SE}, '_epi', fmtwidth{DE}}, x}
}
def widen{D=[8](f64), x:[k](i32) if k>=8} = emit{D, '_mm512_cvtepi32_pd', x86_low_elts{8, x}}
def narrow{(i32), x:[8](f64)} = emit{[8]i32, '_mm512_cvtpd_epi32', x}

local def a5cmp{a:V=[k]E, b:[k]E, int, flt if isfloat{E}} = emit{[k]u1, mr{intrin_t{V, 'cmp'}}, a, b, flt}
local def a5cmp{a:V=[k]E, b:[k]E, int, flt if   isint{E}} = emit{[k]u1, mr{intrin_t{V, 'cmp',int}}, a, b}
def eq_mask{a:V, b:V if has512e{V}} = a5cmp{a, b, 'eq',  0}
def ne_mask{a:V, b:V if has512e{V}} = a5cmp{a, b, 'neq', 4}
def gt_mask{a:V, b:V if has512e{V}} = a5cmp{a, b, 'gt',  30}
def ge_mask{a:V, b:V if has512e{V}} = a5cmp{a, b, 'ge',  29}
def lt_mask{a:V, b:V if has512e{V}} = a5cmp{a, b, 'lt',  17}
def le_mask{a:V, b:V if has512e{V}} = a5cmp{a, b, 'le',  18}

local def masked_op{name, pattern} = {
  def ok{args, k, base} = {
    def got = match (...args) {
      (pattern)
      {..._} => tup{}
    }
    match (got, k, base) {
      {{V=[k]_, ..._}, k, 0  } => 1
      {{V=[k]_, ..._}, k, _:V} => 1
      {..._} => 0
    }
  }
  def me{...args, m:[k](u1), base if ok{args, k, base}} = {
    def {V,...rest} = pattern{...args}
    def has_base = not is{base,0}
    emit{V,
      intrin_i{V, merge{if (has_base) 'mask_' else 'maskz_', name}},
      ...has_base**base,
      m,
      ...rest
    }
  }
}

def masked_op2{name} = masked_op{name, {a:V, b:V if has512e{V}} => tup{V,a,b}}
def masked_op1{name} = masked_op{name, {a:V      if has512e{V}} => tup{V,a}}
def      __add{...} = masked_op2{'add'}
def      __sub{...} = masked_op2{'sub'}
def masked_mov{...} = masked_op1{'mov'}
def   compress{...} = masked_op1{'compress'}


def __and{a:V=[k]E, b:[k](u1) if veci{V}} = masked_mov{a, b, 0}
def  __or{a:V=[k]E, b:[k](u1) if veci{V}} = masked_mov{a, b, hom_ones{[k]E}}
def add_hom_1{a:[k]E, m:[k](u1)} = __sub{a, hom_ones{[k]E}, m, a}
