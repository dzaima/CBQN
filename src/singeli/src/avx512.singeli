local {
  def has512 = x86_has512
  def has512e = x86_has512e
  def intrin = x86_intrin
  def intrin_t = x86_intrin_t
  def intrin_i = x86_intrin_i
  def mt{k} = merge{'mask', fmtnat{__max{k,8}}}
  def mr{s} = merge{s, '_mask'}
}

def store_masked_hom{p:*E, m:[l](u1), v:V=[l]E if has512e{V}} = {
  emit{void, intrin_i{V, 'mask_storeu'}, p, m, v}
}

local def maskop{M=[k](u1), op, ...args} = emit{M, merge{'_k',op,'_',mt{k}}, ...args}
def  __and{a:M=[k](u1), b:M} = maskop{M, 'and', a, b}
def andnot{a:M=[k](u1), b:M} = maskop{M, 'andn', b, a}
def   __or{a:M=[k](u1), b:M} = maskop{M, 'or', a, b}
def  __xor{a:M=[k](u1), b:M} = maskop{M, 'xor', a, b}
def   __ne{a:M=[k](u1), b:M} = maskop{M, 'xor', a, b}
def   __eq{a:M=[k](u1), b:M} = maskop{M, 'xnor', a, b}
def  __not{a:M=[k](u1)} = maskop{M, 'not', a}
def vec_shift_left {a:M=[k](u1), am if int_idx{am, k}} = maskop{M, 'shiftri', a, am}
def vec_shift_right{a:M=[k](u1), am if int_idx{am, k}} = maskop{M, 'shiftli', a, am}
local def real_mask{x:[k](u1) if k<8} = emit{[8]u1, '', x} # in general could have arbitrary bits in the top (esp int_to_mask), but most ops should produce zeroes

def blend_hom{f:V=[k]E, t:V, m:[k](u1)} = emit{V, intrin_i{V, 'mask_blend'}, m, f, t}


# mask conversions
local def mask_int_ty{k} = ty_u{__max{k,8}}
local def mask_int_op{k, s} = if (hasarch{if (k<=8) 'AVX512DQ' else if (k==16) 'AVX512F' else 'AVX512BW'}) s else ''
def hom_to_int{x:[k](u1)} = emit{mask_int_ty{k}, mask_int_op{k, merge{'_cvt',mt{k},'_u',fmtnat{__max{k,32}}}}, x}
def int_to_mask{[k](u1), x:T if isunsigned{T} and width{T}>=k} = emit{[k]u1, mask_int_op{k, merge{'_cvtu',fmtnat{__max{k,32}},'_',mt{k}}}, x}
def int_to_mask{[k](u1), x if int_idx{x, 1<<k}} = int_to_mask{[k]u1, mask_int_ty{k}~~x}
def vec_broadcast{[k](u1), v if (int_idx{v,2} or hastype{v,u1})} = int_to_mask{[k]u1, mask_int_ty{k}~~tail{k} &- u1~~v}

def reinterpret{T, a:M=[l](u1) if isint{T} and l==width{T}} = T~~hom_to_int{a}
def reinterpret{M=[l](u1), a:T if isint{T} and l==width{T}} = int_to_mask{M, a}

local def make_mask{k, vs} = int_to_mask{[k]u1, base{2, vs}}
def vec_make{[k==length{vs}](u1),  ...vs  if all{int_idx{.,2}, vs}} = make_mask{k, vs}
def vec_make{[k==length{vs}](u1), {...vs} if all{int_idx{.,2}, vs}} = make_mask{k, vs}

def top_to_mask{x:V=[k]E if E!=u1 and veci{V}} = emit{[k]u1, mr{intrin{V,'mov',x86_scali{E}}}, x}
def top_to_int{x:V=[_]_ if w512i{V}} = hom_to_int{top_to_mask{x}}
def hom_to_int{x:V=[_]_ if w512i{V}} = top_to_int{x}

def mask_to_hom{V=[l]_, x:[l](u1)} = masked_mov{hom_ones{V}, x, 0}
def mask_to_hom{V=[l]E, x:[l](u1) if hasarch{if (width{E}>=32) 'AVX512DQ' else 'AVX512BW'}} = emit{V, intrin_i{V,'movm'}, x}
def hom_to_hom{V=[k]E, x:[k](u1) if E!=u1} = mask_to_hom{V,x}

def lowelt_mask{[k](u1), n if any_int{n}} = int_to_mask{[k]u1, bzhi{hom_ones{u64}, n}}



# mask tests
local def kortest{a:M=[k](u1), b:M, kind} = emit{u1, merge{'_kortest',kind,'_',mt{k},'_u8'}, a, b}
def any_hom{x:M=[k](u1), y:M} = ~kortest{x, y, 'z'}
def any_hom{x:[k](u1)} = ~kortest{x, x, 'z'}
def all_hom{x:[k](u1) if k>=8} = kortest{x, x, 'c'}
def all_hom{x:[k](u1) if  k<8} = kortest{real_mask{x}, [8]u1~~u8~~zlow{k,0xff}, 'c'}
def any_hom{x:[k](u1), vl if any_int{vl} and not same{vl,k}} = bzhi{promote{u64,hom_to_int{x}}, vl} != 0



# vector tests
def andnz_mask{x:V=[k]E, y:V if has512e{V} and veci{V}} = emit{[k]u1, mr{intrin_i{V, 'test'}}, x, y}
def any_top{x:V=[k]E if w512i{V}} = any_hom{top_to_mask{x}}
def any_hom{x:V=[k]E if w512i{V}} = any_hom{top_to_mask{x}}
def all_top{x:V=[k]E if w512i{V}} = all_hom{top_to_mask{x}}
def all_hom{x:V=[k]E if w512i{V}} = all_hom{top_to_mask{x}}
def and_bit_none{x:V, y:V if w512i{V}} = ~any_hom{andnz_mask{re_el{u8,x}, re_el{u8,y}}}



def sel{(ty_u{V}), x:V=[_]E, i:I==(ty_u{V}) if (if (width{E}>8) has512e{V} else has512{V, 'VBMI'})} = emit{V, intrin_i{V, 'permutexvar'}, i, x}

def extract{x:V=[k]E, i if w512{V} and int_idx{i, k}} = {
  def l = 128/width{E}
  extract{extract{[l]E, x, i >> lb{l}}, i % l}
}

def multishift{a:[k](u64), i:V=[(k*8)](u8) if has512{V, 'VBMI'}} = emit{V, intrin_i{V, 'multishift_epi64'}, i, a}

def narrow{DE, x:[k]SE if isint{DE} and quality{DE}==quality{SE} and x86_has512e{[k]SE}} = {
  emit{x86_vec_low{k,DE}, intrin{[k]SE, 'cvtepi', fmtwidth{SE}, '_epi', fmtwidth{DE}}, x}
}

local def a5cmp{a:V=[k]E, b:[k]E, int, flt if isfloat{E}} = emit{[k]u1, mr{intrin_t{V, 'cmp'}}, a, b, flt}
local def a5cmp{a:V=[k]E, b:[k]E, int, flt if   isint{E}} = emit{[k]u1, mr{intrin_t{V, 'cmp',int}}, a, b}
def eq_mask{a:V, b:V if has512e{V}} = a5cmp{a, b, 'eq',  0}
def ne_mask{a:V, b:V if has512e{V}} = a5cmp{a, b, 'neq', 4}
def gt_mask{a:V, b:V if has512e{V}} = a5cmp{a, b, 'gt',  30}
def ge_mask{a:V, b:V if has512e{V}} = a5cmp{a, b, 'ge',  29}
def lt_mask{a:V, b:V if has512e{V}} = a5cmp{a, b, 'lt',  17}
def le_mask{a:V, b:V if has512e{V}} = a5cmp{a, b, 'le',  18}

local def masked_op{name, pattern} = {
  def ok{args, k, base} = {
    def got = match (...args) {
      (pattern)
      {..._} => tup{}
    }
    match (got, k, base) {
      {{V=[k]_, ..._}, k, 0  } => 1
      {{V=[k]_, ..._}, k, _:V} => 1
      {..._} => 0
    }
  }
  def me{...args, m:[k](u1), base if ok{args, k, base}} = {
    def {V,...rest} = pattern{...args}
    def has_base = not is{base,0}
    emit{V,
      intrin_i{V, merge{if (has_base) 'mask_' else 'maskz_', name}},
      ...has_base**base,
      m,
      ...rest
    }
  }
}

def masked_op1{name} = masked_op{name, {a:V if has512e{V}} => tup{V,a}}
def masked_mov{...} = masked_op1{'mov'}
def   compress{...} = masked_op1{'compress'}
