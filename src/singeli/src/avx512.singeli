local {
  def has512 = x86_has512
  def has512e = x86_has512e
  def intrin = x86_intrin
  def intrin_t = x86_intrin_t
  def intrin_i = x86_intrin_i
  def mt{k} = merge{'mask', fmtnat{__max{k,8}}}
  def mr{s} = merge{s, '_mask'}
  def hasmask{k if k==32 or k==64} = hasarch{'AVX512BW'}
  def hasmask{16} = hasarch{'AVX512F'}
  def hasmask{8} = hasarch{'AVX512DQ'}
}

def store_masked_hom{p:*E, m:[l](u1), v:V=[l]E if has512e{V}} = {
  emit{void, intrin_i{V, 'mask_storeu'}, p, m, v}
}



# mask conversions
def hom_to_int{x:[k](u1)} = emit{ty_u{__max{k,8}}, merge{'_cvt',mt{k},'_u',fmtnat{__max{k,32}}}, x}
def int_to_mask{([8]u1), x:T if isunsigned{T} and width{T}>=8} = emit{[8]u1, '', x}
def int_to_mask{[k](u1), x:T if isunsigned{T} and width{T}>=k and hasmask{k}} = emit{[k]u1, merge{'_cvtu',fmtnat{__max{k,32}},'_',mt{k}}, x}

def reinterpret{T, a:M=[l](u1) if isint{T} and l==width{T}} = T~~hom_to_int{a}
def reinterpret{M=[l](u1), a:T if isint{T} and l==width{T}} = int_to_mask{M, a}

def top_to_mask{x:V=[k]E if E!=u1 and veci{V}} = emit{[k]u1, mr{intrin{V,'mov',x86_scali{E}}}, x}
def top_to_int{x:V=[_]_ if w512i{V}} = hom_to_int{top_to_mask{x}}
def hom_to_int{x:V=[_]_ if w512i{V}} = top_to_int{x}

def mask_to_hom{V=[l]_, x:[l](u1)} = emit{V, intrin_i{V,'movm'}, x}

def lowelt_mask{[k](u1), n if any_int{n}} = int_to_mask{[k]u1, bzhi{hom_ones{u64}, n}}

def sel{(ty_u{V}), x:V=[_]E, i:I==(ty_u{V}) if (if (width{E}>8) has512e{V} else has512{V, 'VBMI'})} = emit{V, intrin_i{V, 'permutexvar'}, i, x}

def multishift{a:[k](u64), i:V=[(k*8)](u8) if has512{V, 'VBMI'}} = emit{V, intrin_i{V, 'multishift_epi64'}, i, a}

def narrow{DE, x:[k]SE if isint{DE} and quality{DE}==quality{SE} and x86_has512e{[k]SE}} = {
  emit{x86_vec_low{k,DE}, intrin{[k]SE, 'cvtepi', fmtwidth{SE}, '_epi', fmtwidth{DE}}, x}
}

local def masked_op{name, pattern} = {
  def ok{args, k, base} = {
    def got = match (...args) {
      (pattern)
      {..._} => tup{}
    }
    match (got, k, base) {
      {{V=[k]_, ..._}, k, 0  } => 1
      {{V=[k]_, ..._}, k, _:V} => 1
      {..._} => 0
    }
  }
  def me{...args, m:[k](u1), base if ok{args, k, base}} = {
    def {V,...rest} = pattern{...args}
    def has_base = not is{base,0}
    emit{V,
      intrin_i{V, merge{if (has_base) 'mask_' else 'maskz_', name}},
      ...has_base**base,
      m,
      ...rest
    }
  }
}

def masked_op1{name} = masked_op{name, {a:V if has512e{V}} => tup{V,a}}
def masked_mov{...} = masked_op1{'mov'}
def   compress{...} = masked_op1{'compress'}
