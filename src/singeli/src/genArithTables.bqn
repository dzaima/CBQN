debug â† 0=â‰ â€¢args
implsâ€¿tables â† 2â†‘â€¢args

T â† =âŠ¸{<â‰ğ•¨â‰âŸğ•¨>ğ•©}

bitâ†0
i8 â†1 â‹„ c8 â†5
i16â†2 â‹„ c16â†6
i32â†3 â‹„ c32â†7
f64â†4
uâ€¿câ€¿eâ€¿rsqâ€¿xsq â† â†•5
tmNoNext â† 1â€¿0â€¿1â€¿1â€¿1
tmChkFnAA â† 0â€¿1â€¿1â€¿0â€¿0
tmLit â† "uceue"

tyWidth â† 99â€¿0â€¿1â€¿2â€¿3â€¿0â€¿1â€¿2 # in log2(bytes)
tyName â† "bit"â€¿"i8"â€¿"i16"â€¿"i32"â€¿"f64"â€¿"c8"â€¿"c16"â€¿"c32"
tySiName â† "u1"â€¿"i8"â€¿"i16"â€¿"i32"â€¿"f64"â€¿"u8"â€¿"u16"â€¿"u32"

mdNone â† 0
mdExact â† 1
mdCast â† 2
mdBit2i8 â† 3
mdF64Chr â† 4
mdSqF64 â† 5

singeliAAFns â† âŸ¨âŸ©
GetSingeliAA â† { tmâ€¿wâ€¿xâ€¿râ€¿idâ€¿si:
  {
    râ‰¡@? @;
    name â† âˆ¾âŸ¨id, "AA", tmâŠ‘tmLit, "_", wâŠ‘tyName, "_", xâŠ‘tyName, "_", râŠ‘tyNameâŸ©
    singeliAAFnsâˆ¾â†© <nameâ€¿wâ€¿xâ€¿râ€¿tmâ€¿si
    name
  }
}

singeliASFns â† âŸ¨âŸ©

nlâ†@+10
cSrc â† ""
siSrc â† ""

Make â† {ğ•Šns:
  cbqnâ€¿reprâ€¿idâ€¿siâ€¿commutative â† ns
  
  # array-array
  aaAâ€¿aaB â† {4â‰¡â‰ ğ•©?ğ•©âˆ¾idâ€¿si; ğ•©}Â¨Â¨ ns.aa_aâ€¿ns.aa_b # add ID and singeli fn to entries that don't have it explicit
  
  currTypes â† â†•8â€¿8
  swap â† 8â€¿8â¥Š0
  {ğ•Š:
    aaAâ€¿aaB {â·ğ•© âˆ¾ âŒ½âŒ¾(1â€¿2âŠ¸âŠ)Â¨ ğ•©}Â¨â†© # allow definitions from either side of the diagonal
    f64chr â† (â‰¥âŸœ5 âˆ§â—‹(âˆ¨Â´Â¨) =âŸœ4) currTypes
    swap â†© <Â´Â¨ â†•8â€¿8 # map of which entries to swap
    currTypes â†© swap âŒ½Â¨ currTypes
  }âŸâŠ¢ commutative
  
  instrs â† â‹ˆÂ¨Â´ {
    map â† ğ•©âŒ¾(({1â€¿2âŠğ•©}Â¨ ğ•©)âŠ¸âŠ‘)âŸ(Ã—â‰ ğ•©) 8â€¿8â¥Š@
    has â† mapâ‰¢Â¨@
    newTypesâ€¿res â† T { ğ•Š si:
      ti â† (ğ•©âŠ¸-+âŒˆÂ´) {(5-ğ•©â‰¥5)|ğ•©} ğ•© # upcast index
      {
        siâ‰¡Â¯1â€¿Â¯1?
          siâ‹ˆmdNone;
        âˆ¨Â´ ti=8? siâŠ‘has? # f64 F chr
          Â¯1â€¿Â¯1â‹ˆmdF64Chr;
        siâŠ‘has? # already has an impl
          siâ‹ˆmdExact;
        âˆ§Â´ tiâ‰ 8? âˆ¨Â´mâ†(isâ†â¥Šsi<âŠ¸+â†•tiÂ¬si)âŠ‘has? # cast one argument up in size
          (âŠ‘m/is)â‹ˆmdCast;
        siâ‰¡0â€¿0? 1â€¿1âŠ‘has? # c_call_wxi8
          1â€¿1â‹ˆmdBit2i8;
        âˆ§Â´ si<5â€¿5? rsqâ‰¡âŠ‘4â€¿4âŠ‘map? # cast both to f64 & squeeze afterwards
          4â€¿4â‹ˆmdSqF64;
        # else
          Â¯1â€¿Â¯1â‹ˆmdNone
      }
    }Â¨ prevTypesâ†currTypes
    updMap â† {ğ•©â‰¡@? ğ•¨; ğ•©}Â´Â¨ (prevTypesâŠ‘map) â‹ˆÂ¨ newTypesâŠ‘map
    typeMap â† {uÂ¨âŒ¾((â¥Š@=ğ•©)/â¥Š)ğ•©} âŠ‘Â¨updMap
    uncheckedMap â† typeMapâŠtmNoNext
    currTypes â†© Â¯1â€¿Â¯1Â¨âŒ¾(uncheckedMap/â—‹â¥ŠâŠ¢) newTypes # remove unchecked operations from next pass
    
    swap â†© 0Â¨ prevSwapâ†swap
    
    (T prevTypesâ€¿newTypesâ€¿typeMapâ€¿updMapâ€¿prevSwap) { pâ€¿nâ€¿tâ€¿eâ€¿sğ•Šğ•©:
      call â† (tâŠ‘tmLit)âˆ¾"_call_"
      mâ†â‰ Â´pâ€¿n
      Type â† {ğ•Š: 3âŠ‘nâŠ‘map}
      âŠ¢â—¶âŸ¨
        @ # mdNone
        {ğ•Š: âŸ¨GetSingeliAA e, t, Type@, callâˆ¾(bit=3âŠ‘nâŠ‘map)âŠ‘"rbyte"â€¿"bit", s, @âŸ©} # mdExact
        {ğ•Š: âŸ¨GetSingeliAA e, t, Type@, callâˆ¾(bit=3âŠ‘nâŠ‘map)âŠ‘"rbyte"â€¿"bit", s, ((sâ‰ m)/"wx")âˆ¾tyNameâŠ‘ËœâŠ‘m/nâŸ©} # mdCast
        {ğ•Š: âŸ¨GetSingeliAA e, t, Type@, callâˆ¾"wxi8", s, @âŸ©} # mdBit2i8
        {ğ•Š: âŸ¨@,            t, @,     "e_call_sqx", s, @âŸ©} # mdF64Chr
        {ğ•Š: âŸ¨GetSingeliAA e, t, Type@, callâˆ¾"wxf64sq", s, @âŸ©} # mdSqF64
      âŸ© ğ•©
    }Â¨ res
  }Â¨ aaAâ€¿aaB
  
  {â€¢Show â‰Ë˜Â¨ğ•©}âŸdebug instrs
  
  cSrcâˆ¾â†© âˆ¾âŸ¨
    "B ", cbqn, "_c2(B,B,B);", nl
    "INIT_GLOBAL DyTableAA ", cbqn,"DyTableAA = {", nl
    "  .entsAA = {", nl
    âˆ¾{ âŸ¨instrs, weâ€¿xeâŸ©:
      {
        instrsâ‰¡@â€¿@? "";
        i0â€¿i1 â† 1â€¿0 {
          ğ•¨ ğ•Š @: "";
          i0 ğ•Š fnâ€¿tâ€¿rtâ€¿exâ€¿swapâ€¿cast:
            ! i0 âˆ¨ Â¬swap
            two â† swap âˆ¨ @â‰¢cast
            âˆ¾âŸ¨âŠ¢â—¶""â€¿{ğ•Š:âˆ¾âŸ¨
              ".ex1=",@âŠ¸â‰¢â—¶âŸ¨"",âˆ¾âŸœ"_"âŸ© cast,swapâŠ‘"reg,"â€¿"swap,"âŸ©} two,
              ".ex", '1'+two, "=", ex,
              @âŠ¸â‰¢â—¶""â€¿{âˆ¾âŸ¨",.type=t_",ğ•©âŠ‘tyName,"arr,.width=",â€¢Repr ğ•©âŠ‘tyWidthâŸ©} rt,
              @âŠ¸â‰¢â—¶""â€¿{âˆ¾âŸ¨",.uFn"â€¿",.cFn"âŠ‘ËœtâŠ‘tmChkFnAA,"=",ğ•©âŸ©} fn
            âŸ©
        }Â¨ instrs
        âˆ¾âŸ¨"    [",â€¢Repr we,"*8+",â€¢Repr xe,"] = {{{", i0, "}, {", i1, "}}},", nlâŸ©
      }
    }Â¨ â¥ŠT âŸ¨instrs â‹„ â†•8â€¿8âŸ©
    "  },", nl
    "  .mainFn = ", cbqn, "_c2,", nl
    "  .repr = """, repr, """", nl
    "};", nl
  âŸ©
  
  # array-scalar / scalar-array
  tyi â† âŸ¨@,  "i8","i16","i32","f64", "i8","i16","i32"âŸ©
  tyc â† âŸ¨@,  "c8","c16","c32",@,     "c8","c16","c32"âŸ©
  isc â† âŸ¨0, 0,    0,    0,    0,     1,   1,    1âŸ©
  { ğ•Š swap:
    choices â† âŒ½âŸswapâŒ¾(2âŠ¸â†‘)Â¨ ns.sa
    hadChrArr â† 0
    _tyMap â† {(ğ”½ ğ•©)âŒ¾((2â†‘Â¨ğ•©='c')âŠ¸âŠ‘) 2â€¿2â¥Š@}
    ResMap â† ('c'=2âŠ‘Â¨âŠ¢) _tyMap
    {
      0â‰¡â‰ ğ•©? @;
      charAtm â† 'c' â‰¡ âŠ‘âŠ‘ğ•©
      hasNumArr  â† âŠ‘'i' âˆŠ 1âŠ‘Â¨ğ•©
      hasChrArr â† âŠ‘'c' âˆŠ 1âŠ‘Â¨ğ•©
      resChr â† ResMap ğ•©
      uncheckedMap â† (âŠ‘Â¨'u'âˆŠÂ¨âŠ¢) _tyMap ğ•©
      argarr â† âŒ½âŸswap "SA"
      canOverflow â† "f64"âŠ¸â‰¢Â¨ tyName
      P â† {âˆ¾âŸ¨"{",ğ•¨,",",ğ•©,"}"âŸ©}Â´
      
      cSrcâˆ¾â†© âˆ¾âŸ¨
        "INIT_GLOBAL DyTableSA ", cbqn,"DyTable", âŒ½âŸswap (charAtmâŠ‘"NC")âˆ¾"A", " = {", nl
        "  .ents = {", nl
        "    {.bitsel=", hasNumArrâ—¶âŸ¨"bad", {ğ•Š:idâˆ¾swap/"R"}âŸ© @, "_forBitsel", charAtmâŠ‘"NC", "N_SA},", nl
        âˆ¾{ ğ•Š num:
          onlyFirst â† ns.overflowEqâŠ‘ âŸ¨1, Â¬numâŠ‘canOverflowâŸ©
          f1â€¿f2 â† 1â€¿2 {
            ğ•©â‰¢@?
            charArr â† numâŠ‘isc
            Â¬ (charAtmâˆ§Â¬numâŠ‘canOverflow) âˆ¨ (onlyFirst âˆ§ ğ•¨=2) âˆ¨ (Â¬hasChrArr)âˆ§charArr?
            currRes â† charAtmâ€¿charArrâŠ‘resChr
            unchFn2 â† charAtmâ€¿charArrâŠ‘uncheckedMap
            currResâ‰¢@?
            twâ†numâŠ‘charAtmâŠ‘tyiâ€¿tyc â‹„ txâ†numâŠ‘tyName â‹„ trâ†ğ•©âŠ‘currResâŠ‘tyiâ€¿tyc
            trâ‰¢@?
            siName â† âˆ¾âŸ¨id, argarr, ğ•¨âŠ‘"?ce", âˆ¾'_'âŠ¸âˆ¾Â¨ twâ€¿txâ€¿trâŸ©
            ğ•¨ { ğ•Š:
              siSrcâˆ¾â†© âˆ¾âŸ¨"export{'", siName, "', arith_sa{", '0'+ ğ•¨âŠ‘âŸ¨@, onlyFirstâŠ‘0â€¿2, unchFn2âŠ‘1â€¿3âŸ©, ',', si, ',', '0'+swap, âˆ¾(',' âˆ¾ 'u'âŒ¾âŠ‘âŸ('c'â‰¡âŠ‘))Â¨ twâ€¿txâ€¿tr, "}}", nlâŸ©
              singeliASFnsâˆ¾â†© <siName
            }âŸâŠ¢ Â¬âŠ‘(<siName)âˆŠsingeliASFns
            siName;
            "failAtomArr"âˆ¾'0'+ğ•¨
          }Â¨ âŸ¨numâŠ‘@â€¿1â€¿2â€¿3â€¿4â€¿5â€¿6â€¿7,
              numâŠ‘@â€¿2â€¿3â€¿4â€¿@â€¿6â€¿7â€¿@âŸ©
          âˆ¾âŸ¨"    {.f1=",f1,", .f2=",f2,"},", nlâŸ©
        }Â¨ 1+â†•7
        "  },", nl
        "  .chrAtom = ", hadChrArrâ—¶"NULL"â€¿{ğ•Š: âˆ¾âŸ¨"&",cbqn,"DyTable", âŒ½âŸswap "CA"âŸ©} @, ",", nl
        "  .mainFn = ", cbqn, "_c2", swap/"R", ",", nl
        "  .fill = ", P PÂ¨ <Ë˜ '0'+@â€¿0â€¿1âŠResMap choices, ",", nl
        "  .repr = """, repr, """", nl
        "};", nl
      âŸ©
      
      hadChrArrâˆ¨â†© charAtm
    }Â¨ 2â†‘(("ci"âŠâŠ‘Â¨)âŠ”âŠ¢) choices
  }Â¨ â†•2-commutative
  
  siSrcâˆ¾â†© nl
}




# definitions
{
  # TODO when there's singeli div/sqrt, use scalar for like 1-2 tail elements
  # aa_a/aa_b: list of âŸ¨mode, w, x, râŸ©
  # sa: list of "wxr", with an appended "u" if widened case can't error
  c_numDiag â† âŸ¨câ€¿i8â€¿i8â€¿i8,  câ€¿i16â€¿i16â€¿i16, câ€¿i32â€¿i32â€¿i32, uâ€¿f64â€¿f64â€¿f64âŸ©
  u_numDiag â† âŸ¨uâ€¿i8â€¿i8â€¿i8,  uâ€¿i16â€¿i16â€¿i16, uâ€¿i32â€¿i32â€¿i32, uâ€¿f64â€¿f64â€¿f64âŸ©
  w_numDiag â† âŸ¨uâ€¿i8â€¿i8â€¿i16, uâ€¿i16â€¿i16â€¿i32, uâ€¿i32â€¿i32â€¿f64âŸ©
  bitand â† âŸ¨uâ€¿bitâ€¿bitâ€¿bitâ€¿"and"â€¿"__and"âŸ©
  bitor  â† âŸ¨uâ€¿bitâ€¿bitâ€¿bitâ€¿"or"â€¿"__or"âŸ©
  Make {
    commutativeâ‡1 â‹„ reprâ‡"+" â‹„ cbqnâ‡"add" â‹„ siâ‡"__add" â‹„ idâ‡"add"
    aa_a â‡ c_numDiagâˆ¾âŸ¨câ€¿i8â€¿c8â€¿c8,  câ€¿i16â€¿c16â€¿c16, eâ€¿i32â€¿c32â€¿c32, xsqâ€¿c8â€¿f64â€¿@, xsqâ€¿c16â€¿f64â€¿@, xsqâ€¿c32â€¿f64â€¿@âŸ©âˆ¾âŸ¨câ€¿i8â€¿i16â€¿i16, câ€¿i8â€¿i32â€¿i32, câ€¿i16â€¿i32â€¿i32âŸ©
    aa_b â‡ w_numDiagâˆ¾âŸ¨eâ€¿i8â€¿c8â€¿c16, eâ€¿i16â€¿c16â€¿c32âŸ©
    saâ‡"iiiu"â€¿"icc"â€¿"cic" â‹„ overflowEqâ‡1
  }
  Make {
    commutativeâ‡0 â‹„ reprâ‡"-" â‹„ cbqnâ‡"sub" â‹„ siâ‡"__sub" â‹„ idâ‡"sub"
    aa_a â‡ c_numDiagâˆ¾âŸ¨câ€¿c8â€¿c8â€¿i8,  câ€¿c16â€¿c16â€¿i16, uâ€¿c32â€¿c32â€¿i32âŸ©âˆ¾âŸ¨câ€¿c8â€¿i8â€¿c8,  câ€¿c16â€¿i16â€¿c16, eâ€¿c32â€¿i32â€¿c32âŸ©âˆ¾âŸ¨xsqâ€¿c8â€¿f64â€¿@, xsqâ€¿c16â€¿f64â€¿@, xsqâ€¿c32â€¿f64â€¿@âŸ©
    aa_b â‡ w_numDiagâˆ¾âŸ¨uâ€¿c8â€¿c8â€¿i16, uâ€¿c16â€¿c16â€¿i32âŸ©               âˆ¾âŸ¨eâ€¿c8â€¿i8â€¿c16, eâ€¿c16â€¿i16â€¿c32âŸ©
    saâ‡"iiiu"â€¿"cic"â€¿"cciu" â‹„ overflowEqâ‡1
  }
  MakeÂ¨ { reprâ€¿cbqn:
    commutativeâ‡1 â‹„ reprâ€¿cbqnâ‡ â‹„ siâ‡"__mul" â‹„ idâ‡"mul"
    aa_a â‡ bitandâˆ¾c_numDiagâˆ¾âŸ¨uâ€¿bitâ€¿i8â€¿i8, uâ€¿bitâ€¿i16â€¿i16, uâ€¿bitâ€¿i32â€¿i32âŸ© # no uâ€¿bitâ€¿f64â€¿f64 because 0Ã—âˆ etc
    aa_b â‡ w_numDiag
    saâ‡âŸ¨"iiiu"âŸ© â‹„ overflowEqâ‡1
  }Â¨ âŸ¨"Ã—"â€¿"mul", "âˆ§"â€¿"and"âŸ©
  Make {
    commutativeâ‡1 â‹„ reprâ‡"âˆ¨" â‹„ cbqnâ‡"or" â‹„ siâ‡"bqn_or" â‹„ idâ‡"or"
    aa_a â‡ bitorâˆ¾âŸ¨rsqâ€¿f64â€¿f64â€¿f64âŸ© # TODO maybe new instr to squeeze arguments & try to go bitarr-bitarr
    aa_b â‡ âŸ¨âŸ©                      # and maybe use that for âˆ§ but not Ã—
    saâ‡âŸ¨âŸ© â‹„ overflowEqâ‡1
  }
  Make {
    commutativeâ‡1 â‹„ reprâ‡"âŒŠ" â‹„ cbqnâ‡"floor" â‹„ siâ‡"__min" â‹„ idâ‡"min"
    aa_a â‡ bitandâˆ¾u_numDiag â‹„ aa_b â‡ âŸ¨âŸ©
    saâ‡âŸ¨"iiiu"âŸ© â‹„ overflowEqâ‡0
  }
  Make {
    commutativeâ‡1 â‹„ reprâ‡"âŒˆ" â‹„ cbqnâ‡"ceil" â‹„ siâ‡"__max" â‹„ idâ‡"max"
    aa_a â‡ bitorâˆ¾u_numDiag â‹„ aa_b â‡ âŸ¨âŸ©
    saâ‡âŸ¨"iiiu"âŸ© â‹„ overflowEqâ‡0
  }
  # MakeÂ¨ { reprâ€¿cbqnâ€¿si:
  #   commutativeâ‡0 â‹„ reprâ€¿cbqnâ€¿siâ‡ â‹„ idâ‡cbqn
  #   aa_a â‡ âŸ¨rsqâ€¿f64â€¿f64â€¿f64âŸ© â‹„ aa_b â‡ âŸ¨âŸ©
  #   saâ‡"i" â‹„ asâ‡"i" â‹„ overflowEqâ‡1
  # }Â¨ âŸ¨"Ã·"â€¿"div"â€¿"__div", "âˆš"â€¿"root"â€¿@, "|"â€¿"stile"â€¿@, "â‹†"â€¿"pow"â€¿@, "â‹†â¼"â€¿"log"â€¿@âŸ©
}

GenSingeli â† { ğ•Šnameâ€¿wâ€¿xâ€¿râ€¿tmâ€¿si:
  siâ‰¢@?
    siSrc âˆ¾â†© âˆ¾âŸ¨"export{'", name, "', arith_aa{", '0'+tm, ',', si, ',', wâŠ‘tySiName, ',', xâŠ‘tySiName, ',', râŠ‘tySiName, "}}", nlâŸ©;
  # else
    @
}

GenSingeliÂ¨ â·singeliAAFns

âŠ¢â—¶{ğ•Š:
  impls â€¢FChars siSrc
  tables â€¢FChars cSrc
}â€¿{ğ•Š:
  â€¢Out cSrc
  â€¢Out siSrc
  1
} debug