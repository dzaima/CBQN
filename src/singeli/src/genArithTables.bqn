debug â† 0=â‰ â€¢args
â€¢term.OutRawâŸdebug âˆ¾âŸ¨@+27 â‹„ "[H" â‹„ @+27 â‹„ "[2J" â‹„ @+27 â‹„ "[3J"âŸ©
â€¢OutâŸ(3Ã—debug) 200â¥Š'-'
implsâ€¿tables â† 2â†‘â€¢args

T â† =âŠ¸{<â‰ğ•¨â‰âŸğ•¨>ğ•©}

bitâ†0
i8 â†1 â‹„ c8 â†5
i16â†2 â‹„ c16â†6
i32â†3 â‹„ c32â†7
f64â†4
uâ€¿câ€¿eâ€¿rsqâ€¿xsq â† â†•5
tmNoNext â† 1â€¿0â€¿1â€¿1â€¿1
tmCheckedFn â† 0â€¿1â€¿1â€¿0â€¿0
tmLit â† "uceue"

tyWidth â† 99â€¿0â€¿1â€¿2â€¿3â€¿0â€¿1â€¿2 # in log2(bytes)
tyName â† "bit"â€¿"i8"â€¿"i16"â€¿"i32"â€¿"f64"â€¿"c8"â€¿"c16"â€¿"c32"
tySiType â† "u1"â€¿"i8"â€¿"i16"â€¿"i32"â€¿"f64"â€¿"u8"â€¿"u16"â€¿"u32"

ShowTbl â† {
  # ğ•© â†© {âˆ§Â´â¥Šğ•©â‰¡Â¨@? @; ğ•©/Ëœğ•©â‰¢Â¨@}Â¨ ğ•©
  ğ•© â‰Ë˜âŸ=Â¨ â†©
  â€¢Show ğ•©
  #â€¢Out â€¢Repr ğ•©
}âŸdebug

mdNone â† 0
mdExact â† 1
mdCast â† 2
mdBit2i8 â† 3
mdF64Chr â† 4
mdSqF64 â† 5

singeliFns â† âŸ¨âŸ©
GetSingeli â† { tmâ€¿wâ€¿xâ€¿râ€¿idâ€¿si:
  {
    râ‰¡@? @;
    name â† âˆ¾âŸ¨id, "AA", tmâŠ‘tmLit, "_", wâŠ‘tyName, "_", xâŠ‘tyName, "_", râŠ‘tyNameâŸ©
    singeliFnsâˆ¾â†© <nameâ€¿wâ€¿xâ€¿râ€¿tmâ€¿si
    name
  }
}

nlâ†@+10
cSrc â† ""
Make â† {ğ•Šns:
  cbqnâ€¿reprâ€¿idâ€¿siâ€¿commutative â† ns
  
  aaAâ€¿aaB â† {4â‰¡â‰ ğ•©?ğ•©âˆ¾idâ€¿si; ğ•©}Â¨Â¨ ns.aa_aâ€¿ns.aa_b # add ID and singeli fn to entries that don't have it explicit
  
  currTypes â† â†•8â€¿8
  swap â† 8â€¿8â¥Š0
  {ğ•Š:
    aaAâ€¿aaB {â·ğ•© âˆ¾ âŒ½âŒ¾(1â€¿2âŠ¸âŠ)Â¨ ğ•©}Â¨â†© # allow definitions from either side of the diagonal
    f64chr â† (â‰¥âŸœ5 âˆ§â—‹(âˆ¨Â´Â¨) =âŸœ4) currTypes
    swap â†© <Â´Â¨ â†•8â€¿8 # map of which entries to swap
    currTypes â†© swap âŒ½Â¨ currTypes
  }âŸâŠ¢ commutative
  
  instrs â† â‹ˆÂ¨Â´ {
    map â† ğ•©âŒ¾(({1â€¿2âŠğ•©}Â¨ ğ•©)âŠ¸âŠ‘)âŸ(Ã—â‰ ğ•©) 8â€¿8â¥Š@
    has â† mapâ‰¢Â¨@
    newTypesâ€¿res â† T { ğ•Š si:
      ti â† (ğ•©âŠ¸-+âŒˆÂ´) {(5-ğ•©â‰¥5)|ğ•©} ğ•© # upcast index
      {
        siâ‰¡Â¯1â€¿Â¯1?
          siâ‹ˆmdNone;
        âˆ¨Â´ ti=8? siâŠ‘has? # f64 F chr
          Â¯1â€¿Â¯1â‹ˆmdF64Chr;
        siâŠ‘has? # already has an impl
          siâ‹ˆmdExact;
        âˆ§Â´ tiâ‰ 8? âˆ¨Â´mâ†(isâ†â¥Šsi<âŠ¸+â†•tiÂ¬si)âŠ‘has? # cast one argument up in size
          (âŠ‘m/is)â‹ˆmdCast;
        siâ‰¡0â€¿0? 1â€¿1âŠ‘has? # c_call_wxi8
          1â€¿1â‹ˆmdBit2i8;
        âˆ§Â´ si<5â€¿5? rsqâ‰¡âŠ‘4â€¿4âŠ‘map? # cast both to f64 & squeeze afterwards
          4â€¿4â‹ˆmdSqF64;
        # else
          Â¯1â€¿Â¯1â‹ˆmdNone
      }
    }Â¨ prevTypesâ†currTypes
    updMap â† {ğ•©â‰¡@? ğ•¨; ğ•©}Â´Â¨ (prevTypesâŠ‘map) â‹ˆÂ¨ newTypesâŠ‘map
    typeMap â† {uÂ¨âŒ¾((â¥Š@=ğ•©)/â¥Š)ğ•©} âŠ‘Â¨updMap
    uncheckedMap â† typeMapâŠtmNoNext
    currTypes â†© Â¯1â€¿Â¯1Â¨âŒ¾(uncheckedMap/â—‹â¥ŠâŠ¢) newTypes # remove unchecked operations from next pass
    
    swap â†© 0Â¨ prevSwapâ†swap
    
    (T prevTypesâ€¿newTypesâ€¿typeMapâ€¿updMapâ€¿prevSwap) { pâ€¿nâ€¿tâ€¿eâ€¿sğ•Šğ•©:
      call â† (tâŠ‘tmLit)âˆ¾"_call_"
      mâ†â‰ Â´pâ€¿n
      Type â† {ğ•Š: 3âŠ‘nâŠ‘map}
      âŠ¢â—¶âŸ¨
        @ # mdNone
        {ğ•Š: âŸ¨GetSingeli e, t, Type@, callâˆ¾(bit=3âŠ‘nâŠ‘map)âŠ‘"rbyte"â€¿"bit", s, @âŸ©} # mdExact
        {ğ•Š: âŸ¨GetSingeli e, t, Type@, callâˆ¾(bit=3âŠ‘nâŠ‘map)âŠ‘"rbyte"â€¿"bit", s, ((sâ‰ m)/"wx")âˆ¾tyNameâŠ‘ËœâŠ‘m/nâŸ©} # mdCast
        {ğ•Š: âŸ¨GetSingeli e, t, Type@, callâˆ¾"wxi8", s, @âŸ©} # mdBit2i8
        {ğ•Š: âŸ¨@,            t, @,     "e_call_sqx", s, @âŸ©} # mdF64Chr
        {ğ•Š: âŸ¨GetSingeli e, t, Type@, callâˆ¾"wxf64sq", s, @âŸ©} # mdSqF64
      âŸ© ğ•©
    }Â¨ res
  }Â¨ aaAâ€¿aaB
  
  # ShowTbl âˆ¾Â´Â¨ instrs
  
  cSrcâˆ¾â†© âˆ¾âŸ¨
    "B ", cbqn, "_c2(B,B,B);", nl
    "static DyTable ", cbqn,"DyTable = {", nl
    "  .entsAA = {", nl
    âˆ¾{ âŸ¨instrs, weâ€¿xeâŸ©:
      {
        instrsâ‰¡@â€¿@? "";
        i0â€¿i1 â† 1â€¿0 {
          ğ•¨ ğ•Š @: "";
          i0 ğ•Š fnâ€¿tâ€¿rtâ€¿exâ€¿swapâ€¿cast:
            ! i0 âˆ¨ Â¬swap
            two â† swap âˆ¨ @â‰¢cast
            âˆ¾âŸ¨âŠ¢â—¶""â€¿{ğ•Š:âˆ¾âŸ¨
              ".ex1=",@âŠ¸â‰¢â—¶âŸ¨"",âˆ¾âŸœ"_"âŸ© cast,swapâŠ‘"reg,"â€¿"swap,"âŸ©} two,
              ".ex", '1'+two, "=", ex,
              @âŠ¸â‰¢â—¶""â€¿{âˆ¾âŸ¨",.type=t_",ğ•©âŠ‘tyName,"arr,.width=",â€¢Repr ğ•©âŠ‘tyWidthâŸ©} rt,
              @âŠ¸â‰¢â—¶""â€¿{âˆ¾âŸ¨",.uFn"â€¿",.cFn"âŠ‘ËœtâŠ‘tmCheckedFn,"=",ğ•©âŸ©} fn
            âŸ©
        }Â¨ instrs
        âˆ¾âŸ¨"    [",â€¢Repr we,"*8+",â€¢Repr xe,"] = {{", i0, "}, {", i1, "}},", nlâŸ©
      }
    }Â¨ â¥ŠT âŸ¨instrs â‹„ â†•8â€¿8âŸ©
    "  },", nl
    "  .mainFn = ", cbqn, "_c2,", nl
    "  .repr = """, repr, """", nl
    "};", nl
  âŸ©
}



# TODO unify sub uâ€¿c32â€¿c32â€¿i32 and câ€¿i32â€¿i32â€¿i32?
# TODO when there's singeli div/sqrt, use scalar for like 1-2 tail elements

{ # definitions
  # âŸ¨mode, w, x, râŸ©
  c_numDiag â† âŸ¨câ€¿i8â€¿i8â€¿i8,  câ€¿i16â€¿i16â€¿i16, câ€¿i32â€¿i32â€¿i32, uâ€¿f64â€¿f64â€¿f64âŸ©
  u_numDiag â† âŸ¨uâ€¿i8â€¿i8â€¿i8,  uâ€¿i16â€¿i16â€¿i16, uâ€¿i32â€¿i32â€¿i32, uâ€¿f64â€¿f64â€¿f64âŸ©
  w_numDiag â† âŸ¨uâ€¿i8â€¿i8â€¿i16, uâ€¿i16â€¿i16â€¿i32, uâ€¿i32â€¿i32â€¿f64âŸ©
  bitand â† âŸ¨uâ€¿bitâ€¿bitâ€¿bitâ€¿"and"â€¿"__and"âŸ©
  bitor  â† âŸ¨uâ€¿bitâ€¿bitâ€¿bitâ€¿"or"â€¿"__or"âŸ©
  Make {
    commutativeâ‡1 â‹„ reprâ‡"+" â‹„ cbqnâ‡"add" â‹„ siâ‡"__add" â‹„ idâ‡"add"
    aa_a â‡ c_numDiagâˆ¾âŸ¨câ€¿i8â€¿c8â€¿c8,  câ€¿i16â€¿c16â€¿c16, eâ€¿i32â€¿c32â€¿c32, xsqâ€¿c8â€¿f64â€¿@, xsqâ€¿c16â€¿f64â€¿@, xsqâ€¿c32â€¿f64â€¿@âŸ©âˆ¾âŸ¨câ€¿i8â€¿i16â€¿i16, câ€¿i8â€¿i32â€¿i32, câ€¿i16â€¿i32â€¿i32âŸ©
    aa_b â‡ w_numDiagâˆ¾âŸ¨eâ€¿i8â€¿c8â€¿c16, eâ€¿i16â€¿c16â€¿c32âŸ©
  }
  Make {
    commutativeâ‡0 â‹„ reprâ‡"-" â‹„ cbqnâ‡"sub" â‹„ siâ‡"__sub" â‹„ idâ‡"sub"
    aa_a â‡ c_numDiagâˆ¾âŸ¨câ€¿c8â€¿c8â€¿i8,  câ€¿c16â€¿c16â€¿i16, uâ€¿c32â€¿c32â€¿i32âŸ©âˆ¾âŸ¨câ€¿c8â€¿i8â€¿c8,  câ€¿c16â€¿i16â€¿c16, eâ€¿c32â€¿i32â€¿c32âŸ©âˆ¾âŸ¨xsqâ€¿c8â€¿f64â€¿@, xsqâ€¿c16â€¿f64â€¿@, xsqâ€¿c32â€¿f64â€¿@âŸ©
    aa_b â‡ w_numDiagâˆ¾âŸ¨uâ€¿c8â€¿c8â€¿i16, uâ€¿c16â€¿c16â€¿i32âŸ©               âˆ¾âŸ¨eâ€¿c8â€¿i8â€¿c16, eâ€¿c16â€¿i16â€¿c32âŸ©
  }
  MakeÂ¨ { reprâ€¿cbqn:
    commutativeâ‡1 â‹„ reprâ€¿cbqnâ‡ â‹„ siâ‡"__mul" â‹„ idâ‡"mul"
    aa_a â‡ bitandâˆ¾c_numDiag # âˆ¾âŸ¨uâ€¿bitâ€¿i8â€¿i8, uâ€¿bitâ€¿i16â€¿i16, uâ€¿bitâ€¿i32â€¿i32, uâ€¿bitâ€¿f64â€¿f64âŸ©
    aa_b â‡ w_numDiag        # TODO readd â†‘
  }Â¨ âŸ¨"Ã—"â€¿"mul", "âˆ§"â€¿"and"âŸ©
  Make {
    commutativeâ‡1 â‹„ reprâ‡"âˆ¨" â‹„ cbqnâ‡"or" â‹„ siâ‡"bqn_or" â‹„ idâ‡"or"
    aa_a â‡ bitorâˆ¾âŸ¨rsqâ€¿f64â€¿f64â€¿f64âŸ© # TODO maybe new instr to squeeze arguments & try to go bitarr-bitarr
    aa_b â‡ âŸ¨âŸ©                      # and maybe use that for âˆ§ but not Ã—
  }
  Make {
    commutativeâ‡1 â‹„ reprâ‡"âŒŠ" â‹„ cbqnâ‡"floor" â‹„ siâ‡"min" â‹„ idâ‡"min"
    aa_a â‡ bitandâˆ¾u_numDiag â‹„ aa_b â‡ âŸ¨âŸ©
  }
  Make {
    commutativeâ‡1 â‹„ reprâ‡"âŒˆ" â‹„ cbqnâ‡"ceil" â‹„ siâ‡"max" â‹„ idâ‡"max"
    aa_a â‡ bitorâˆ¾u_numDiag â‹„ aa_b â‡ âŸ¨âŸ©
  }
  # MakeÂ¨ { reprâ€¿cbqnâ€¿si:
  #   commutativeâ‡0 â‹„ reprâ€¿cbqnâ€¿siâ‡ â‹„ idâ‡cbqn
  #   aa_a â‡ âŸ¨rsqâ€¿f64â€¿f64â€¿f64âŸ© â‹„ aa_b â‡ âŸ¨âŸ©
  # }Â¨ âŸ¨"Ã·"â€¿"div"â€¿"__div", "âˆš"â€¿"root"â€¿@, "|"â€¿"stile"â€¿@, "â‹†"â€¿"pow"â€¿@, "â‹†â¼"â€¿"log"â€¿@âŸ©
}

siSrc â† ""
GenSingeli â† { ğ•Šnameâ€¿wâ€¿xâ€¿râ€¿tmâ€¿si:
  siâ‰¢@?
    siSrc âˆ¾â†© âˆ¾âŸ¨"'", name, "'=arithAA{", '0'+tm, ',', si, ',', wâŠ‘tySiType, ',', xâŠ‘tySiType, ',', râŠ‘tySiType, '}', nlâŸ©;
  # else
    @
}

GenSingeliÂ¨ â·singeliFns

âŠ¢â—¶{ğ•Š:
  impls â€¢FChars siSrc
  tables â€¢FChars cSrc
}â€¿{ğ•Š:
  # â€¢Out cSrc
  â€¢Out siSrc
  1
} debug

